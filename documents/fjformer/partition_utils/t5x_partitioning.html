<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fjformer.partition_utils.t5x_partitioning API documentation</title>
<meta name="description" content="Utilities for partitioning." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fjformer.partition_utils.t5x_partitioning</code></h1>
</header>
<section id="section-intro">
<p>Utilities for partitioning.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2023 The T5X Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Utilities for partitioning.&#34;&#34;&#34;

import abc
import collections
import dataclasses
import functools
import typing
from typing import Any, Callable, Optional, Sequence, Set, Tuple, Union

from absl import logging
from flax import traverse_util
from flax.linen import partitioning as flax_partitioning
import jax
from jax import numpy as jnp
from jax import random
from jax.experimental import multihost_utils
from jax.experimental.mesh_utils import create_hybrid_device_mesh
from jax.experimental.pjit import pjit
from jax.sharding import Mesh
from jax.sharding import PartitionSpec
import numpy as np

JaxDevice = jax.Device
TpuMesh = Tuple[int, int, int, int]  # (x, y, z, num_cores).
OtherMesh = Tuple[int, int]
HardwareMesh = Union[TpuMesh, OtherMesh]
LogicalAxisRules = Sequence[Tuple[str, Optional[str]]]

cached_property = property


class AxisNames(tuple):
    &#34;&#34;&#34;Tuple of strings specifying name for each axis.
  
    We create a separate class for this so JAX&#39;s pytree utilities can distinguish
    it from a tuple that should be treated as a pytree, instead treating it as a
    leaf.
    &#34;&#34;&#34;

    def __new__(cls, *names):
        return tuple.__new__(AxisNames, names)

    def __repr__(self):
        return &#39;AxisNames%s&#39; % tuple.__repr__(self)


def with_sharding_constraint(x, axis_resources):
    &#34;&#34;&#34;Wrapper for lax.with_sharding_constraint, no-op on cpu or outside pjit.&#34;&#34;&#34;
    if jax.devices()[0].platform == &#39;cpu&#39; or not global_mesh_defined():
        return x
    else:
        return jax.lax.with_sharding_constraint(x, axis_resources)


def bounds_from_last_device(last_device: jax.Device) -&gt; HardwareMesh:
    &#34;&#34;&#34;Get the bound from the given last device.&#34;&#34;&#34;
    # Must be passed the device at the highest-coordinate corner of the
    # relevant mesh, which is a requirement we know is satisfied by the last
    # device in jax.devices().
    if hasattr(last_device, &#39;coords&#39;):
        x, y, z = last_device.coords
        return x + 1, y + 1, z + 1, last_device.core_on_chip + 1
    else:
        # On non-TPU platforms, the &#34;mesh&#34; is hosts x devices per host in order
        # to take advantage of faster within-host interconnect.
        return jax.process_count(), jax.local_device_count()


def get_coords(device: jax.Device) -&gt; HardwareMesh:
    &#34;&#34;&#34;Returns the coordinates of the given device.&#34;&#34;&#34;
    if hasattr(device, &#39;coords&#39;):
        return *device.coords, device.core_on_chip
    return device.process_index, device.id % jax.local_device_count()


def global_mesh_defined():
    &#34;&#34;&#34;Checks if global xmap/pjit mesh resource environment is defined.&#34;&#34;&#34;
    maps_env = jax.experimental.maps.thread_resources.env
    return maps_env.physical_mesh.devices.shape != ()  # pylint: disable=g-explicit-bool-comparison


def get_mesh(model_parallel_submesh: HardwareMesh,
             input_devices: Sequence[JaxDevice] = (),
             input_local_devices: Sequence[JaxDevice] = (),
             tile_by_host_if_needed: bool = True,
             backend: Optional[str] = None) -&gt; Mesh:
    &#34;&#34;&#34;Construct an xmap/pjit Mesh for the given model-parallel submesh.
  
    The resulting mesh has two resource axes: &#39;model&#39;, with the provided submesh
    shape, and &#39;data&#39;, which covers the rest of the mesh.
  
    Args:
      model_parallel_submesh: a HardwareMesh spec, namely (x,y,z,core) on TPU for
        a single model-parallel replica&#39;s &#34;tile&#34; in the physical device mesh. The
        first three elements (`x`, `y`, and `z`) should be factors of the pod
        slice; e.g., if you are using df_4x8, then `x` should be a factor of 4
        (one of 1, 2, 4), `y` should be a factor of 8 (one of 1, 2, 4, 8), and `z`
        must be 1, because TPU v3 slices are only 2D. `z` can be &gt;1 for TPU v4
        (and maybe later TPUs) that allow 3D slices. `core` is the number of cores
        to use from each TPU node. As communication is usually fastest inside the
        same node, if you need a tile of more than 1 core, then
        you should first increase `core`: e.g., for TPU v3, (1,1,1,2) is better
          than (2,1,1,1). To pick a good spec, try a few possible values until you
          get high TPU utilization.
      input_devices: the devices to use, will use jax.devices() if this is not
        set.
      input_local_devices: the local devices to use, will use jax.local_devices()
        if this is not set.
      tile_by_host_if_needed: JAX currently requires that the parts of any sharded
        array that are located on one host&#39;s local devices form a single
        contiguous slice. A best effort will be made to achieve this without
        &#34;tiling&#34; the device assignment over hosts (which can reduce XLA collective
        performance). If this flag is True, then the device assignment will be
        tiled over hosts if necessary to satisfy this constraint and create a
        buildable mesh; if false, mesh construction will fail instead.
      backend: get devices from the pinned backend, if specified. This is
        useful for explicitly specifying the devices other than relying on
        jax_platform_name.
  
    Returns:
      A xmap / pjit Mesh containing the virtual device mesh with data, model axes.
    &#34;&#34;&#34;
    input_devices = input_devices or jax.devices(backend)
    input_local_devices = input_local_devices or jax.local_devices(0, backend)
    # Sort input_devices based on coords, as backends might not return devices
    # in order.
    last_device = sorted(input_devices, key=get_coords)[-1]
    last_input_local_devices = sorted(input_local_devices, key=get_coords)[-1]
    logging.info(&#39;last device coords : %r\nlast local device coords: %r&#39;,
                 get_coords(last_device), get_coords(last_input_local_devices))
    global_hardware_mesh = bounds_from_last_device(last_device)
    mesh_ndim = len(global_hardware_mesh)
    local_hardware_mesh = bounds_from_last_device(last_input_local_devices)
    mesh_err = (
        f&#39;each dimension of the model parallel submesh {model_parallel_submesh} &#39;
        &#39;must be a factor of the corresponding dimension of the global device &#39;
        f&#39;mesh {global_hardware_mesh}&#39;)
    assert not any(
        g % m
        for g, m in zip(global_hardware_mesh, model_parallel_submesh)), mesh_err
    assert not any(
        g % l for g, l in zip(global_hardware_mesh, local_hardware_mesh))
    devices = np.empty(global_hardware_mesh, dtype=object)
    for device in input_devices:
        device_coords = get_coords(device)
        devices[device_coords] = device
    tile_by_host = tile_by_host_if_needed
    if len(global_hardware_mesh) == 4:
        # enable contiguous local chunks without host tiling by making Z major
        global_hardware_mesh = typing.cast(Tuple[int, int, int, int],
                                           global_hardware_mesh)
        model_parallel_submesh = typing.cast(Tuple[int, int, int, int],
                                             model_parallel_submesh)
        gx, gy, gz, gc = global_hardware_mesh
        mx, my, mz, mc = model_parallel_submesh
        if (mx == gx &gt; 1 and my == mz == 1) or (mx == 1 and my == gy &gt; 1 and
                                                mz == gz &gt; 1):
            logging.info(&#39;ensuring YZ plane has a Z-major device order&#39;)
            # YZ should be ZY
            assert mc == gc, (mc, gc)
            global_hardware_mesh = gx, gz, gy, gc
            model_parallel_submesh = mx, mz, my, mc
            devices = devices.swapaxes(1, 2)
            tile_by_host = False
        if (my == gy &gt; 1 and mx == mz == 1) or (my == 1 and mx == gx &gt; 1 and
                                                mz == gz &gt; 1):
            logging.info(&#39;ensuring XZ plane has a Z-major device order&#39;)
            # XZ should be ZX
            assert mc == gc, (mc, gc)
            global_hardware_mesh = gz, gy, gx, gc
            model_parallel_submesh = mz, my, mx, mc
            devices = devices.swapaxes(0, 2)
            tile_by_host = False
    if tile_by_host:
        logging.warning(
            &#39;Tiling device assignment mesh by hosts, which may lead to &#39;
            &#39;reduced XLA collective performance. To avoid this, modify &#39;
            &#39;the model parallel submesh or run with more tasks per host.&#39;)
        tile_err = (
            &#39;to tile the mesh by hosts, each dimension of the model parallel &#39;
            &#39;submesh must be either a factor or a multiple of the corresponding &#39;
            &#39;dimension of the per-host submesh&#39;)

        def dh_dd_mh_md(g: int, m: int, l: int) -&gt; Tuple[int, int, int, int]:
            &#34;&#34;&#34;Split a global mesh dimension into four tiling components.
      
            Args:
              g: global mesh bounds dimension size
              m: model-parallel submesh bounds dimension size
              l: local submesh bounds dimension size
      
            Returns:
              The resulting tuple divides the dimension into the hosts component of
              the data-parallel submesh, the devices component of the data-parallel
              submesh, the hosts component of the model-parallel submesh, and the
              devices component of the model-parallel submesh.
            &#34;&#34;&#34;
            d = g // m
            if m &gt;= l:
                assert not m % l, tile_err
                return d, 1, m // l, l
            else:
                assert not l % m, tile_err
                return d // (l // m), l // m, 1, m

        dh_dd_mh_md_tups = map(dh_dd_mh_md, global_hardware_mesh,
                               model_parallel_submesh, local_hardware_mesh)
        devices = devices.reshape(*(s for t in dh_dd_mh_md_tups for s in t))
        devices = devices.transpose(*(4 * i for i in range(mesh_ndim)),
                                    *(4 * i + 1 for i in range(mesh_ndim)),
                                    *(4 * i + 2 for i in range(mesh_ndim)),
                                    *(4 * i + 3 for i in range(mesh_ndim)))
    else:
        model_data_tups = [
            (g // m, m)
            for g, m in zip(global_hardware_mesh, model_parallel_submesh)
        ]
        devices = devices.reshape(*(s for t in model_data_tups for s in t))
        devices = devices.transpose(*(2 * i for i in range(mesh_ndim)),
                                    *(2 * i + 1 for i in range(mesh_ndim)))
    # reshape to (data, model)
    devices = devices.reshape(-1, np.prod(model_parallel_submesh))
    global_mesh = Mesh(devices, [&#39;data&#39;, &#39;model&#39;])
    logging.info(&#39;global_mesh axis_names: %s&#39;, global_mesh.axis_names)
    logging.info(&#39;global_mesh devices: %s&#39;, global_mesh.devices)
    logging.info(&#39;global_mesh devices shape: %s&#39;, global_mesh.devices.shape)
    return global_mesh


def get_cpu_mesh() -&gt; Mesh:
    &#34;&#34;&#34;Trivial mesh for CPU Testing.&#34;&#34;&#34;
    devices = np.empty(
        (jax.process_count(), jax.local_device_count()), dtype=object
    )
    for device in jax.devices():
        devices[device.process_index, device.id % jax.local_device_count()] = device
    return Mesh(devices, [&#39;data&#39;, &#39;model&#39;])


def get_gpu_mesh(num_partitions: int) -&gt; Mesh:
    &#34;&#34;&#34;Mesh for GPUs that preferentially places &#39;model&#39; on NVLink.&#34;&#34;&#34;
    nvlink_size = jax.local_device_count()
    dcn_size = jax.process_count()
    nvlink_mp = min(num_partitions, nvlink_size)
    nvlink_dp, extra1 = divmod(nvlink_size, nvlink_mp)
    dcn_mp, extra2 = divmod(num_partitions, nvlink_mp)
    assert not (extra1 or extra2), (&#39;number of partitions on GPU must be a factor&#39;
                                    &#39; or multiple of the number of local devices&#39;)
    dcn_dp = dcn_size // dcn_mp

    devices = create_hybrid_device_mesh(
        mesh_shape=[nvlink_dp, nvlink_mp],
        dcn_mesh_shape=[dcn_dp, dcn_mp],
        process_is_granule=True)

    global_mesh = Mesh(devices, [&#39;data&#39;, &#39;model&#39;])
    logging.info(&#39;global_mesh axis_names: %s&#39;, global_mesh.axis_names)
    logging.info(&#39;global_mesh devices: %s&#39;, global_mesh.devices)
    return global_mesh


def default_mesh(
        num_partitions: int,
        model_parallel_submesh: Optional[HardwareMesh] = None,
        backend: Optional[str] = None,
        ici_mesh_shape: Optional[HardwareMesh] = None,
        dcn_mesh_shape: Optional[HardwareMesh] = None,
) -&gt; Mesh:
    &#34;&#34;&#34;Attempt to return a default mesh for simple cases.
  
    Args:
      num_partitions: number of partitions to use, will be ignored if
        model_parallel_submesh is provided.
      model_parallel_submesh: 4-tuple that specifies the x,y,z,c submesh to use as
        the model-parallel device tile.
      backend: get devices from the pinned backend, if specified. This is useful
        for explicitly specifying the devices other than relying on
        jax_platform_name.
      ici_mesh_shape: Shape of the logical mesh used for SPMD parallelism in each
        slice. The meaning of each mesh axis is defined by mesh_axis_names, so
        these two params must be the same length. If dcn_mesh_shape is present,
        the overall mesh is the product of ici_mesh_shape and dcn_mesh_shape. For
        example, an ici_mesh_shape of [2, 3, 4] with mesh_axis_names [&#39;replica&#39;,
        &#39;data&#39;, &#39;model&#39;] indicates 2-way replica parallelism, 3-way data
        parallelism, and 4-way model parallelism over 24 devices. None, the
        default, is equivalent to a sequence of ones and means that the model is
        placed on a single device.
      dcn_mesh_shape: Shape of the logical mesh used for SPMD parallelism over
        multiple slices. The overall mesh is the product of ici_mesh_shape and
        dcn_mesh_shape, and the meaning of each mesh axis is defined by
        mesh_axis_names, so these three params must be the same length.
  
    Returns:
      xmap/pjit 2D Mesh with &#39;data&#39;, &#39;model&#39; mesh axes if single-slice, otherwise
      3D Mesh with &#39;replica&#39;, &#39;data&#39;, and &#39;model&#39; mesh axes.
    &#34;&#34;&#34;
    devices = jax.devices(backend)
    last_device = devices[-1]
    platform = last_device.platform
    device_kind = last_device.device_kind
    bounds = bounds_from_last_device(last_device)

    if ici_mesh_shape is not None and dcn_mesh_shape is not None:
        device_mesh = create_hybrid_device_mesh(
            ici_mesh_shape,
            dcn_mesh_shape,
            devices=devices,
        )
        multi_slice_global_mesh = Mesh(device_mesh, [&#39;replica&#39;, &#39;data&#39;, &#39;model&#39;])
        logging.info(
            &#39;multi_slice_global_mesh axis_names: %s&#39;,
            multi_slice_global_mesh.axis_names,
        )
        logging.info(
            &#39;multi_slice_global_mesh devices: %s&#39;, multi_slice_global_mesh.devices
        )
        logging.info(
            &#39;multi_slice_global_mesh devices shape: %s&#39;,
            multi_slice_global_mesh.devices.shape,
        )
        return multi_slice_global_mesh

    if model_parallel_submesh:
        return get_mesh(model_parallel_submesh, backend=backend)

    if platform == &#39;cpu&#39;:
        return get_cpu_mesh()
    elif platform == &#39;gpu&#39;:
        return get_gpu_mesh(num_partitions)

    mps = None
    if device_kind in (&#39;TPU v2&#39;, &#39;TPU v3&#39;):
        if num_partitions == 1:
            mps = (1, 1, 1, 1)
        elif num_partitions == 2:
            mps = (1, 1, 1, 2)
        elif num_partitions == 4:
            mps = (2, 1, 1, 2)
        elif num_partitions == 8:
            mps = (2, 2, 1, 2)
        elif num_partitions == 16:
            mps = (4, 2, 1, 2)
    # assume the use of megacore on TPU v4
    elif (device_kind == &#39;TPU v4&#39; or
          device_kind == &#39;TPU v4 lite&#39;) and bounds[3] == 1:
        if num_partitions == 1:
            mps = (1, 1, 1, 1)
        elif num_partitions == 2:
            mps = (1, 2, 1, 1)
        elif num_partitions == 4:
            if bounds[0] &gt;= 4:
                mps = (4, 1, 1, 1)
            else:
                mps = (2, 2, 1, 1)
        elif num_partitions == 8:
            if bounds[2] &gt;= 8:
                mps = (1, 1, 8, 1)
            else:
                mps = (4, 2, 1, 1)
        elif num_partitions == 16:
            if bounds[2] &gt;= 16:
                mps = (1, 1, 16, 1)
            elif bounds[0] &gt;= 8:
                mps = (8, 2, 1, 1)
            elif bounds[0] &gt;= 4:
                mps = (4, 4, 1, 1)
            else:
                mps = (2, 2, 4, 1)

    if mps is None:
        raise ValueError(
            &#39;No default mesh for this configuration: specify &#39;
            &#39;config.model_parallel_submesh explicitly. \n&#39;
            f&#39;Platform: {platform}\n&#39;
            f&#39;Device kind: {device_kind}\n&#39;
            f&#39;Num partitions: {num_partitions}\n&#39;
            f&#39;Bounds: {bounds}&#39;
        )
    return get_mesh(mps, backend=backend)


# Data chunking helper.
# -----------------------------------------------------------------------------
@dataclasses.dataclass
class LocalChunkInfo:
    # The logical slice of an array located on this host&#39;s local devices.
    slice: Tuple[slice, ...]
    # A unique index for this host/local chunk among chunks with the same slice.
    replica_id: int


class LocalChunker:
    &#34;&#34;&#34;Utility class to aid chunking of sharded arrays in multihost settings.&#34;&#34;&#34;

    def __init__(self, global_mesh: Mesh):
        self.global_mesh = global_mesh
        local_mesh = global_mesh.local_mesh
        first_local_device = local_mesh.devices.reshape(-1)[0]
        host_location = collections.OrderedDict(
            zip(
                global_mesh.shape.keys(),
                list(zip(*np.nonzero(
                    global_mesh.devices == first_local_device)))[0]))
        self.num_chunks = collections.OrderedDict()
        self.chunk_ids = collections.OrderedDict()
        self.mesh_axes = list(global_mesh.shape.keys())
        for mesh_axis in self.mesh_axes:
            num_devices_per_chunk = local_mesh.shape[mesh_axis]
            self.num_chunks[mesh_axis] = (
                    global_mesh.shape[mesh_axis] // num_devices_per_chunk)
            self.chunk_ids[mesh_axis] = (
                    host_location[mesh_axis] // num_devices_per_chunk)

    def get_local_chunk_info(
            self, global_shape: Tuple[int, ...],
            mesh_axes: Sequence[Optional[str]]) -&gt; LocalChunkInfo:
        &#34;&#34;&#34;Get the local chunk info for a given array shape and sharded axes.
    
        Args:
          global_shape: the global, unsharded shape of the array to chunk.
          mesh_axes: a sequence of names (or None) of equal rank to `global_shape`
            that specifies which mesh dimensions the array is sharded along.
    
        Returns:
          LocalChunkInfo containing the logical slices of the array found on this
          host&#39;s local devices, as well as the replica index for this chunk among
          chunks with the same slice. The latter is used to determine which
          host should write this chunk during checkpointing.
        &#34;&#34;&#34;
        local_slice = [slice(None) for dim in global_shape]
        sharded_mesh_axes = set()
        for i, (mesh_axis, size) in enumerate(zip(mesh_axes, global_shape)):
            if not mesh_axis:
                continue
            sharded_mesh_axes.add(mesh_axis)
            if not isinstance(mesh_axis, str):
                raise NotImplementedError(&#39;TODO(jekbradbury)&#39;)
            chunk_id = self.chunk_ids[mesh_axis]
            chunk_size = size // self.num_chunks[mesh_axis]
            local_slice[i] = slice(chunk_id * chunk_size, (chunk_id + 1) * chunk_size)

        replica_id = self.get_replica_id(sharded_mesh_axes)

        return LocalChunkInfo(tuple(local_slice), replica_id)

    def get_shard_id(self, sharded_mesh_axes: str | Set[Optional[str]]) -&gt; int:
        &#34;&#34;&#34;Given mesh axes used for sharding, computes current host&#39;s shard id.
    
        To give an example, let&#39;s say there are two axes globally: replica, data,
        and model, the mesh axes for sharding is (&#39;replica&#39;, &#39;data&#39;), which means we
        are going to partition an array along &#39;replica&#39; and &#39;data&#39; axes.
        The shard_id is to show the index of the current local host along the
        sharding axes (in this example, it&#39;s &#39;replica&#39; and &#39;data&#39; axes).
    
        More concretely, let&#39;s say we have 4 local hosts, and we use &#39;replica&#39; and
        &#39;data&#39; axes for data parallel (2 hosts along the replica axis, and 2 host
        along the data axis). The host located in (&#39;replica&#39;: 0, &#39;data&#39;: 0), we
        should assign data shard-0 to it. For host (&#39;replica&#39;: 0, &#39;data&#39;: 1), we
        assign shard-1. For host (&#39;replica&#39;: 1, &#39;data&#39;: 0), we assign shard-2.
        For host (&#39;replica&#39;: 1, &#39;data&#39;: 1), we assign shard-3.
    
        Note: the host location along &#39;replica&#39; and &#39;data&#39; axes, e.g.,
        (&#39;replica&#39;: 0, &#39;data&#39;: 0) is named chunk_id and stored in
        self._local_chunker.chunk_ids[axis].
    
        Args:
          sharded_mesh_axes: the mesh axes for sharding.
    
        Returns:
          the index of the current local host along the sharding axes.
        &#34;&#34;&#34;
        if isinstance(sharded_mesh_axes, str):
            sharded_mesh_axes = (sharded_mesh_axes,)

        shard_id = 0
        for mesh_axis in sharded_mesh_axes:
            chunk_id = self.chunk_ids[mesh_axis]
            shard_id = shard_id * self.num_chunks[mesh_axis] + chunk_id

        return shard_id

    def get_replica_id(self, sharded_mesh_axes: str | Set[Optional[str]]) -&gt; int:
        &#34;&#34;&#34;Given mesh axes used for sharding, computes current host&#39;s replica id.
    
        To give an example, let&#39;s say there are two axes globally: data, and model,
        the mesh axes for sharding is (&#39;data&#39;, ), which means we are going to
        partition an array along &#39;data&#39; axis and replicate it along &#39;model&#39; axis.
        The replica_id is to show the index of the current local host along the
        &#39;model&#39; axis.
    
        Args:
          sharded_mesh_axes: the mesh axes for sharding.
    
        Returns:
          the index of the current local host along the non-sharding axes (i.e.,
          replicating axes).
        &#34;&#34;&#34;
        if isinstance(sharded_mesh_axes, str):
            sharded_mesh_axes = (sharded_mesh_axes,)

        replicated_mesh_axes = [
            mesh_axis for mesh_axis in self.mesh_axes
            if mesh_axis not in sharded_mesh_axes
        ]
        replica_id = 0
        for mesh_axis in replicated_mesh_axes:
            chunk_id = self.chunk_ids[mesh_axis]
            replica_id = replica_id * self.num_chunks[mesh_axis] + chunk_id

        return replica_id


def standard_logical_axis_rules(
        activation_partitioning_dims: int = 1,
        parameter_partitioning_dims: int = 1,
        additional_rules: Optional[LogicalAxisRules] = None) -&gt; LogicalAxisRules:
    &#34;&#34;&#34;Default sharding rules for T5X model in terms of logical axis names.
  
    Args:
      activation_partitioning_dims: enables 2-D activation sharding when set to 2.
      parameter_partitioning_dims: enables 2-D parameter sharding when set to 2.
      additional_rules: additional rules (a sequence of tuples) that will be
        appended to the standard rules.
  
    Returns:
      Sequence of logical axis rules
    &#34;&#34;&#34;
    logging.info(
        &#39;`activation_partitioning_dims` = %d, `parameter_partitioning_dims` = %d&#39;,
        activation_partitioning_dims, parameter_partitioning_dims)

    if activation_partitioning_dims == 1 and parameter_partitioning_dims == 1:
        rules = [
            (&#39;batch&#39;, &#39;data&#39;),
            (&#39;vocab&#39;, &#39;model&#39;),
            (&#39;embed&#39;, None),
            (&#39;mlp&#39;, &#39;model&#39;),
            (&#39;heads&#39;, &#39;model&#39;),
            (&#39;kv&#39;, None),
            (&#39;joined_kv&#39;, &#39;model&#39;),  # joined heads+kv dim in 2D attn param layouts
        ]
    elif activation_partitioning_dims == 2 and parameter_partitioning_dims == 1:
        rules = [
            (&#39;batch&#39;, &#39;data&#39;),
            (&#39;vocab&#39;, &#39;model&#39;),
            (&#39;mlp&#39;, &#39;model&#39;),
            (&#39;heads&#39;, &#39;model&#39;),
            (&#39;kv&#39;, None),
            (&#39;joined_kv&#39;, &#39;model&#39;),
            (&#39;embed&#39;, &#39;model&#39;),
        ]
    elif activation_partitioning_dims == 1 and parameter_partitioning_dims == 2:
        rules = [
            (&#39;batch&#39;, &#39;data&#39;),
            (&#39;vocab&#39;, &#39;model&#39;),
            (&#39;mlp&#39;, &#39;model&#39;),
            (&#39;heads&#39;, &#39;model&#39;),
            (&#39;kv&#39;, None),
            (&#39;joined_kv&#39;, &#39;model&#39;),
            (&#39;embed&#39;, &#39;data&#39;),
        ]
    elif activation_partitioning_dims == 2 and parameter_partitioning_dims == 2:
        rules = [
            (&#39;batch&#39;, &#39;data&#39;),
            (&#39;vocab&#39;, &#39;model&#39;),
            (&#39;mlp&#39;, &#39;model&#39;),
            (&#39;heads&#39;, &#39;model&#39;),
            (&#39;kv&#39;, None),
            (&#39;joined_kv&#39;, &#39;model&#39;),
            (&#39;embed&#39;, &#39;model&#39;),
            (&#39;embed&#39;, &#39;data&#39;),
        ]
    else:
        raise ValueError(
            f&#39;`activation_partitioning_dims` = {activation_partitioning_dims} &#39;
            f&#39;`parameter_partitioning_dims` = {parameter_partitioning_dims} &#39;
            &#39;is not supported.&#39;)

    # Add the common rules for the replicated logical axes names.
    replicated_rules = [
        (&#39;relpos_buckets&#39;, None),
        (&#39;abspos_buckets&#39;, None),
        (&#39;length&#39;, None),
        (&#39;layers&#39;, None),
        (&#39;stack&#39;, None),
        (&#39;mlp_activations&#39;, None),
    ]
    rules.extend(replicated_rules)

    if additional_rules:
        rules.extend(additional_rules)

    return rules


# NB: This needs to be top-level for the jax compilation cache.
def _id_fn(x, ix):
    &#34;&#34;&#34;Identity function for copying parameters to the devices, sharded.&#34;&#34;&#34;
    # A pure identity such as `lambda x, *: x` can get optimized away, so we
    # include a random.split as a cheap function that cannot be optimized away.
    y = random.split(random.PRNGKey(jnp.array(ix, dtype=jnp.uint32)))
    return x, y


@dataclasses.dataclass
class DataLayout:
    &#34;&#34;&#34;Represents data layout for the partitioned model.&#34;&#34;&#34;
    batch_size: int
    shard_id: int
    num_shards: int
    is_first_host_in_replica_set: bool


PartitionedCallable = Callable[..., Any]
CompiledPartitionedCallable = Callable[..., Any]


class BasePartitioner(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Interface for partitioning computations across hardware devices.&#34;&#34;&#34;

    def __init__(
            self,
            num_partitions: Optional[int] = None,
            model_parallel_submesh: Optional[HardwareMesh] = None,
            params_on_devices: bool = True,
            backend: Optional[str] = None,
            ici_mesh_shape: Optional[HardwareMesh] = None,
            dcn_mesh_shape: Optional[HardwareMesh] = None,
    ):
        &#34;&#34;&#34;Configures the partitioner.
    
        Args:
          num_partitions: the number of partitions to use. Ignored if
            `model_parallel_submesh` is provided.
          model_parallel_submesh: 4-tuple that specifies the x,y,z,c submesh to use
            as the model-parallel device tile. This submesh is used for the larger
            of the two parameter dimensions, and, if 2-D activation sharding is
            enabled, for the model dimension of activations. The rest of the mesh is
            used for data parallelism and, if 2-D parameter sharding is enabled, the
            other parameter dimension.
          params_on_devices: whether to keep the params on devices, if False -
            params stay in the host memory. Note that some partitioners might ignore
            this setting, for example if they don&#39;t support storing all params on
            device memory.
          backend: get devices from the pinned backend, if specified. This is useful
            for explicitly specifying the devices other than relying on
            jax_platform_name.
          ici_mesh_shape: Shape of the logical mesh used for SPMD parallelism in
            each slice. The meaning of each mesh axis is defined by mesh_axis_names,
            so these two params must be the same length. If dcn_mesh_shape is
            present, the overall mesh is the product of ici_mesh_shape and
            dcn_mesh_shape. For example, an ici_mesh_shape of [2, 3, 4] with
            mesh_axis_names [&#39;replica&#39;, &#39;data&#39;, &#39;mdl&#39;] indicates 2-way replica
            parallelism, 3-way data parallelism, and 4-way model parallelism over 24
            devices. None, the default, is equivalent to a sequence of ones and
            means that the model is placed on a single device.
          dcn_mesh_shape: Shape of the logical mesh used for SPMD parallelism over
            multiple slices. The overall mesh is the product of ici_mesh_shape and
            dcn_mesh_shape, and the meaning of each mesh axis is defined by
            mesh_axis_names, so these three params must be the same length.
        &#34;&#34;&#34;

        if not num_partitions and not model_parallel_submesh:
            raise ValueError(&#39;At least one of `num_partitions` or &#39;
                             &#39;`model_parallel_submesh` must be set.&#39;)

        if model_parallel_submesh is not None and len(model_parallel_submesh) != 4:
            logging.error(
                (
                    &#39;`model_parallel_submesh` must be either None or a 4-tuple. Got&#39;
                    &#39; `model_parallel_submesh`=%r. A ValueError will be raised&#39;
                    &#39; beginning March 1, 2022.&#39;
                ),
                model_parallel_submesh,
            )

        if bool(num_partitions) and bool(model_parallel_submesh):
            logging.error(
                &#39;At most one of `num_partitions` or `model_parallel_submesh` can be &#39;
                &#39;set. Got `num_partitions=%r` and `model_parallel_submesh`=%r. A &#39;
                &#39;ValueError will be raised beginning March 21, 2022.&#39;,
                num_partitions,
                model_parallel_submesh,
            )

        self._num_partitions = num_partitions
        self._model_parallel_submesh = model_parallel_submesh
        self._params_on_devices = params_on_devices
        if ici_mesh_shape is None or dcn_mesh_shape is None:
            self._data_axis = &#39;data&#39;
        else:
            self._data_axis = (&#39;replica&#39;, &#39;data&#39;)
        self._backend = backend
        self._ici_mesh_shape = ici_mesh_shape
        self._dcn_mesh_shape = dcn_mesh_shape

    @property
    def mesh(self) -&gt; Mesh:
        raise NotImplementedError

    @property
    def data_partition_spec(self) -&gt; PartitionSpec:
        return PartitionSpec(self._data_axis)

    @property
    def data_mesh_size(self) -&gt; int:
        &#34;&#34;&#34;Data mesh size.
    
        Data mesh size is defined as the number of global devices involved to
        carry out data parallel. Let&#39;s say we have a global mesh: (&#39;replica&#39;: 2,
        &#39;data&#39;: 4, &#39;model&#39;: 2), and axes &#39;replica&#39; and &#39;data&#39; are responsible for
        the data parallel, that means we have 2*4 = 8 devices involved - i.e., data
        mesh size is 8.
    
        Returns:
          the id of the shard for the axes being replicated among the devices used
          to shard the sharded_mesh_axes.
        &#34;&#34;&#34;
        data_submesh_sizes = (
            [self.mesh.shape[self._data_axis]]
            if isinstance(self._data_axis, str)
            else [self.mesh.shape[axis] for axis in self._data_axis]
        )
        data_mesh_size = functools.reduce(lambda x, y: x * y, data_submesh_sizes)
        return data_mesh_size

    @property
    def data_shards(self) -&gt; int:
        &#34;&#34;&#34;Number of data shards.
    
        Let&#39;s say we are dealing with 2 slices of df4x2 TPUs. In data pipeline
        we need prepare / send one data shard to each local host. This means, we
        need 4 shards since we have 4 local hosts. How to infer the number of hosts
        from mesh information? In this case, we have a global mesh: (&#39;replica&#39;: 2,
        &#39;data&#39;: 8, &#39;model&#39;: 2). Each local host (i.e., df2x2) has this local mesh:
        (&#39;replica&#39;: 1, &#39;data&#39;: 4, &#39;model&#39;: 2). By dividing global mesh with local
        mesh, we can get the count of hosts.
    
        Returns:
          Number of data shards. Each shard will be sent to one local host.
        &#34;&#34;&#34;
        data_chunks = (
            [self._local_chunker.num_chunks[self._data_axis]]
            if isinstance(self._data_axis, str)
            else [self._local_chunker.num_chunks[axis] for axis in self._data_axis]
        )
        data_shards = functools.reduce(lambda x, y: x * y, data_chunks)
        return data_shards

    @property
    def data_shard_id(self) -&gt; int:
        &#34;&#34;&#34;Data shard id for the current host.
    
        Returns:
          Index of data shard that will be sent to the current local host.
        &#34;&#34;&#34;
        return self._local_chunker.get_shard_id(self._data_axis)

    def get_data_layout(
            self, batch_size: Optional[int] = None, host_index: Optional[int] = None
    ) -&gt; DataLayout:
        &#34;&#34;&#34;Returns filled `DataLayout` based on the partitioned model layout.
    
        Args:
          batch_size: if set, indicates the requested batch size. The exception will
            be raised if this batch size is not compatible with the layout. If not
            set, the batch size is inferred from the layout.
          host_index: indicates the host index to use for the calculations, if not
            set - use JAX-provided one. Should be in [0, num_hosts) interval and the
            order should match the order of corresponding CPU devices in
            `jax.devices()`.
    
        Returns:
          Filled `DataLayout` structure.
        &#34;&#34;&#34;
        if host_index is not None:
            raise NotImplementedError(&#39;Explicit host_index is not yet implemented.&#39;)
        if self._data_axis is None:
            return DataLayout(
                batch_size=batch_size,
                shard_id=0,
                num_shards=1,
                is_first_host_in_replica_set=(jax.process_index() == 0))

        batch_size = batch_size or self.data_mesh_size
        if batch_size % self.data_mesh_size:
            raise ValueError(
                f&#39;Batch size ({batch_size}) must be divisible by corresponding &#39;
                f&#39;data mesh size ({self.data_mesh_size}).&#39;
            )

        if batch_size % self.data_shards:
            raise ValueError(
                f&#39;Batch size ({batch_size}) must be divisible by number of &#39;
                f&#39;data shards ({self.data_shards}).&#39;
            )
        replica_id = self._local_chunker.get_replica_id(self._data_axis)
        return DataLayout(
            batch_size=int(batch_size),
            shard_id=int(self.data_shard_id),
            num_shards=int(self.data_shards),
            is_first_host_in_replica_set=(replica_id == 0),
        )

    def get_local_chunk_info(
            self, global_shape: Tuple[int, ...],
            mesh_axes: Sequence[Optional[str]]) -&gt; LocalChunkInfo:
        &#34;&#34;&#34;Returns the local chunk info for a given array shape and sharded axes.&#34;&#34;&#34;
        return self._local_chunker.get_local_chunk_info(global_shape, mesh_axes)

    @property
    def params_on_devices(self):
        return self._params_on_devices

    @params_on_devices.setter
    def params_on_devices(self, value):
        self._params_on_devices = value

    def move_params_to_devices(self, train_state,
                               train_state_axes):
        &#34;&#34;&#34;Moves the optimizer parameters to devices.&#34;&#34;&#34;
        p_id_fn = self.partition(
            _id_fn,
            in_axis_resources=(train_state_axes, None),
            out_axis_resources=(train_state_axes, None),
            donate_argnums=(0,))
        if jax.process_count() &gt; 1:
            train_state = host_local_array_to_global_array(
                train_state, self.mesh, train_state_axes
            )
        train_state, _ = p_id_fn(train_state, jnp.ones((), dtype=jnp.uint32))
        return train_state

    @property
    @abc.abstractmethod
    def _local_chunker(self):
        &#34;&#34;&#34;Returns the chunker that matches the parameters of this partitioner.&#34;&#34;&#34;
        raise NotImplementedError

    def get_logical_axes(self, train_state):
        &#34;&#34;&#34;Returns a copy of TrainState with Optional[AxisNames] as leaves.&#34;&#34;&#34;
        # By default, return None for the logical axes.
        return train_state.restore_state(
            jax.tree_map(lambda x: None, train_state.state_dict()))

    def get_mesh_axes(self, train_state):
        &#34;&#34;&#34;Returns a copy of TrainState with Optional[PartitionSpecs] as leaves.&#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def partition(
            self,
            fn: Callable,  # pylint: disable=g-bare-generic
            in_axis_resources,
            out_axis_resources,
            static_argnums: Union[int, Sequence[int]] = (),
            donate_argnums: Union[int, Sequence[int]] = ()
    ) -&gt; PartitionedCallable:
        raise NotImplementedError

    @abc.abstractmethod
    def compile(self, partitioned_fn: PartitionedCallable,
                *args) -&gt; CompiledPartitionedCallable:

        raise NotImplementedError


class PjittedFnWithContext(PartitionedCallable):
    &#34;&#34;&#34;Wraps pjitted function to apply the appropriate contexts.&#34;&#34;&#34;

    def __init__(self,
                 pjitted_fn,
                 partition_mesh: Mesh,
                 logical_axis_rules: flax_partitioning.LogicalRules = ()):
        self._pjitted_fn = pjitted_fn
        self._mesh = partition_mesh
        self._logical_axis_rules = logical_axis_rules

    def __call__(self, *args, **kwargs):
        with Mesh(self._mesh.devices,
                  self._mesh.axis_names), flax_partitioning.axis_rules(self._logical_axis_rules):
            return self._pjitted_fn(*args, **kwargs)

    def lower(self, *args, **kwargs):
        with Mesh(self._mesh.devices,
                  self._mesh.axis_names), flax_partitioning.axis_rules(self._logical_axis_rules):
            return self._pjitted_fn.lower(*args, **kwargs)


class BasePjitPartitioner(BasePartitioner):
    &#34;&#34;&#34;Partitioner that uses T5X version of jax.pjit.&#34;&#34;&#34;

    @cached_property
    def _local_chunker(self) -&gt; LocalChunker:
        return LocalChunker(self.mesh)

    @cached_property
    def mesh(self) -&gt; Mesh:
        return default_mesh(
            self._num_partitions,
            self._model_parallel_submesh,
            self._backend,
            self._ici_mesh_shape,
            self._dcn_mesh_shape,
        )

    def partition(
            self,
            fn: Callable,  # pylint: disable=g-bare-generic
            in_axis_resources,
            out_axis_resources,
            static_argnums: Union[int, Sequence[int]] = (),
            donate_argnums: Union[int, Sequence[int]] = (),
    ) -&gt; PjittedFnWithContext:
        pjitted = pjit(
            fn,
            in_shardings=in_axis_resources,
            out_shardings=out_axis_resources,
            static_argnums=static_argnums,
            donate_argnums=donate_argnums,
        )

        return PjittedFnWithContext(pjitted, self.mesh)

    def compile(self, partitioned_fn: PjittedFnWithContext,
                *args) -&gt; CompiledPartitionedCallable:
        return partitioned_fn.lower(*args).compile()


class PjitPartitioner(BasePjitPartitioner):
    &#34;&#34;&#34;Partitioner that uses named axes and jax.pjit.&#34;&#34;&#34;

    def __init__(
            self,
            num_partitions: Optional[int] = None,
            model_parallel_submesh: Optional[HardwareMesh] = None,
            params_on_devices: bool = True,
            backend: Optional[str] = None,
            ici_mesh_shape: Optional[HardwareMesh] = None,
            dcn_mesh_shape: Optional[HardwareMesh] = None,
            logical_axis_rules: Optional[LogicalAxisRules] = None,
    ):
        &#34;&#34;&#34;PjitPartitioner constructor.
    
        See https://github.com/google-research/text-to-text-transfer-transformer/blob/main/README.mdx/usage/partitioning for details.
    
        Args:
          num_partitions: an integer that specifies the size of the model parallel
            submesh to be automatically selected for the current topology. See
            `model_parallel_submesh` for details on how this submesh is used.
            Mutually exclusive with `model_parallel_submesh`.
          model_parallel_submesh: is a 4-tuple that specifies the `(x, y, z, c)`
            submesh model-parallel device tile, an axis of accelerator parallelism
            orthogonal to data parallelism. Array axes in a model&#39;s parameters or
            activations can be sharded over this submesh using axis rules (see
            `logical_axis_rules`) that map them to &#39;model&#39;. The effective number of
            model sub-partitions is equal to `np.prod(model_parallel_submesh)` and
            must evenly divide the total number of devices (i.e.,
            `jax.device_count() % np.prod(model_parallel_submesh) == 0`). The rest
            of the TPU mesh is the data parallel submesh, providing
            `jax.device_count() // np.prod(model_parallel_submesh)` partitions. It
            is used for data (batch) parallelism and to shard other array axes that
            are mapped to &#39;data&#39;. This argument is mutually exclusive with
            `num_partitions`.
          params_on_devices: whether to keep the params on devices, if False -
            params stay in the host memory. Note that some partitioners might ignore
            this setting, for example if they don&#39;t support storing all params on
            device memory.
          backend: get devices from the pinned backend, if specified. This is useful
            for explicitly specifying the devices other than relying on
            jax_platform_name.
          ici_mesh_shape: Shape of the logical mesh used for SPMD parallelism in
            each slice. The meaning of each mesh axis is defined by mesh_axis_names,
            so these two params must be the same length. If dcn_mesh_shape is
            present, the overall mesh is the product of ici_mesh_shape and
            dcn_mesh_shape. For example, an ici_mesh_shape of [2, 3, 4] with
            mesh_axis_names [&#39;replica&#39;, &#39;data&#39;, &#39;model&#39;] indicates 2-way replica
            parallelism, 3-way data parallelism, and 4-way model parallelism over 24
            devices. None, the default, is equivalent to a sequence of ones and
            means that the model is placed on a single device.
          dcn_mesh_shape: Shape of the logical mesh used for SPMD parallelism over
            multiple slices. The overall mesh is the product of ici_mesh_shape and
            dcn_mesh_shape, and the meaning of each mesh axis is defined by
            mesh_axis_names, so these three params must be the same length.
          logical_axis_rules: a priority-ordered sequence of KV tuples that maps
            logical axis names to either `None` (not sharded), &#39;model&#39; (to shard
            across the model-parallel submesh), or &#39;data&#39; (to shard across the
            data-parallel submesh).
        &#34;&#34;&#34;
        super().__init__(
            num_partitions=num_partitions,
            model_parallel_submesh=model_parallel_submesh,
            params_on_devices=params_on_devices,
            backend=backend,
            ici_mesh_shape=ici_mesh_shape,
            dcn_mesh_shape=dcn_mesh_shape,
        )
        if logical_axis_rules is None:
            logical_axis_rules = standard_logical_axis_rules()
        if ici_mesh_shape is not None and dcn_mesh_shape is not None:
            # Split batch over new replica axis.
            logical_axis_rules = (
                (k, (&#39;replica&#39;, &#39;data&#39;) if k == &#39;batch&#39; else v)
                for k, v in logical_axis_rules
            )
        self._logical_axis_rules = tuple(logical_axis_rules)
        (self._data_axis,) = flax_partitioning.logical_to_mesh_axes(
            [&#39;batch&#39;], self._logical_axis_rules
        )

    def partition(
            self,
            fn: Callable,  # pylint: disable=g-bare-generic
            in_axis_resources,
            out_axis_resources,
            static_argnums: Union[int, Sequence[int]] = (),
            donate_argnums: Union[int, Sequence[int]] = ()
    ) -&gt; PjittedFnWithContext:
        &#34;&#34;&#34;Partitions the function using jax.pjit.&#34;&#34;&#34;
        pjitted = pjit(
            fn,
            in_shardings=in_axis_resources,
            out_shardings=out_axis_resources,
            static_argnums=static_argnums,
            donate_argnums=donate_argnums,
        )

        return PjittedFnWithContext(pjitted, self.mesh, self._logical_axis_rules)

    @property
    def logical_axis_rules(self):
        &#34;&#34;&#34;Returns the logical axis rules.&#34;&#34;&#34;
        return self._logical_axis_rules

    def get_logical_axes(self, train_state):
        &#34;&#34;&#34;Returns a copy of TrainState with Optional[AxisNames] as leaves.&#34;&#34;&#34;
        return train_state.as_logical_axes()

    def get_mesh_axes(self, train_state):
        &#34;&#34;&#34;Returns a copy of TrainState with Optional[PartitionSpecs] as leaves.&#34;&#34;&#34;
        logical_axes = self.get_logical_axes(train_state)

        def _logical_to_mesh_axes(param_name, logical_axes):
            if logical_axes is None:
                return None
            elif logical_axes is traverse_util.empty_node:
                return traverse_util.empty_node
            try:
                return flax_partitioning.logical_to_mesh_axes(logical_axes,
                                                              self._logical_axis_rules)
            except ValueError as e:
                raise ValueError(f&#39;Failed to map logical axes for {param_name}&#39;) from e

        flat_logical_axes = traverse_util.flatten_dict(
            logical_axes.state_dict(), keep_empty_nodes=True, sep=&#39;/&#39;)
        flat_mesh_axes = {
            k: _logical_to_mesh_axes(k, v) for k, v in flat_logical_axes.items()
        }

        return logical_axes.restore_state(
            traverse_util.unflatten_dict(flat_mesh_axes, sep=&#39;/&#39;))


def host_local_array_to_global_array(arr_tree, mesh: jax.sharding.Mesh, pspecs):
    pspecs = jax.tree_map(
        lambda x: PartitionSpec() if x is None else x,
        pspecs,
        is_leaf=lambda x: x is None,
    )
    return multihost_utils.host_local_array_to_global_array(
        arr_tree, mesh, pspecs
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.bounds_from_last_device"><code class="name flex">
<span>def <span class="ident">bounds_from_last_device</span></span>(<span>last_device:jaxlib.xla_extension.Device) >Union[Tuple[int,int,int,int],Tuple[int,int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the bound from the given last device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounds_from_last_device(last_device: jax.Device) -&gt; HardwareMesh:
    &#34;&#34;&#34;Get the bound from the given last device.&#34;&#34;&#34;
    # Must be passed the device at the highest-coordinate corner of the
    # relevant mesh, which is a requirement we know is satisfied by the last
    # device in jax.devices().
    if hasattr(last_device, &#39;coords&#39;):
        x, y, z = last_device.coords
        return x + 1, y + 1, z + 1, last_device.core_on_chip + 1
    else:
        # On non-TPU platforms, the &#34;mesh&#34; is hosts x devices per host in order
        # to take advantage of faster within-host interconnect.
        return jax.process_count(), jax.local_device_count()</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.default_mesh"><code class="name flex">
<span>def <span class="ident">default_mesh</span></span>(<span>num_partitions:int, model_parallel_submesh:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None, backend:Optional[str]=None, ici_mesh_shape:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None, dcn_mesh_shape:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None) >jax._src.mesh.Mesh</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to return a default mesh for simple cases.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_partitions</code></strong></dt>
<dd>number of partitions to use, will be ignored if
model_parallel_submesh is provided.</dd>
<dt><strong><code>model_parallel_submesh</code></strong></dt>
<dd>4-tuple that specifies the x,y,z,c submesh to use as
the model-parallel device tile.</dd>
<dt><strong><code>backend</code></strong></dt>
<dd>get devices from the pinned backend, if specified. This is useful
for explicitly specifying the devices other than relying on
jax_platform_name.</dd>
<dt><strong><code>ici_mesh_shape</code></strong></dt>
<dd>Shape of the logical mesh used for SPMD parallelism in each
slice. The meaning of each mesh axis is defined by mesh_axis_names, so
these two params must be the same length. If dcn_mesh_shape is present,
the overall mesh is the product of ici_mesh_shape and dcn_mesh_shape. For
example, an ici_mesh_shape of [2, 3, 4] with mesh_axis_names ['replica',
'data', 'model'] indicates 2-way replica parallelism, 3-way data
parallelism, and 4-way model parallelism over 24 devices. None, the
default, is equivalent to a sequence of ones and means that the model is
placed on a single device.</dd>
<dt><strong><code>dcn_mesh_shape</code></strong></dt>
<dd>Shape of the logical mesh used for SPMD parallelism over
multiple slices. The overall mesh is the product of ici_mesh_shape and
dcn_mesh_shape, and the meaning of each mesh axis is defined by
mesh_axis_names, so these three params must be the same length.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>xmap/pjit 2D Mesh with 'data', 'model' mesh axes if single-slice, otherwise
3D Mesh with 'replica', 'data', and 'model' mesh axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_mesh(
        num_partitions: int,
        model_parallel_submesh: Optional[HardwareMesh] = None,
        backend: Optional[str] = None,
        ici_mesh_shape: Optional[HardwareMesh] = None,
        dcn_mesh_shape: Optional[HardwareMesh] = None,
) -&gt; Mesh:
    &#34;&#34;&#34;Attempt to return a default mesh for simple cases.
  
    Args:
      num_partitions: number of partitions to use, will be ignored if
        model_parallel_submesh is provided.
      model_parallel_submesh: 4-tuple that specifies the x,y,z,c submesh to use as
        the model-parallel device tile.
      backend: get devices from the pinned backend, if specified. This is useful
        for explicitly specifying the devices other than relying on
        jax_platform_name.
      ici_mesh_shape: Shape of the logical mesh used for SPMD parallelism in each
        slice. The meaning of each mesh axis is defined by mesh_axis_names, so
        these two params must be the same length. If dcn_mesh_shape is present,
        the overall mesh is the product of ici_mesh_shape and dcn_mesh_shape. For
        example, an ici_mesh_shape of [2, 3, 4] with mesh_axis_names [&#39;replica&#39;,
        &#39;data&#39;, &#39;model&#39;] indicates 2-way replica parallelism, 3-way data
        parallelism, and 4-way model parallelism over 24 devices. None, the
        default, is equivalent to a sequence of ones and means that the model is
        placed on a single device.
      dcn_mesh_shape: Shape of the logical mesh used for SPMD parallelism over
        multiple slices. The overall mesh is the product of ici_mesh_shape and
        dcn_mesh_shape, and the meaning of each mesh axis is defined by
        mesh_axis_names, so these three params must be the same length.
  
    Returns:
      xmap/pjit 2D Mesh with &#39;data&#39;, &#39;model&#39; mesh axes if single-slice, otherwise
      3D Mesh with &#39;replica&#39;, &#39;data&#39;, and &#39;model&#39; mesh axes.
    &#34;&#34;&#34;
    devices = jax.devices(backend)
    last_device = devices[-1]
    platform = last_device.platform
    device_kind = last_device.device_kind
    bounds = bounds_from_last_device(last_device)

    if ici_mesh_shape is not None and dcn_mesh_shape is not None:
        device_mesh = create_hybrid_device_mesh(
            ici_mesh_shape,
            dcn_mesh_shape,
            devices=devices,
        )
        multi_slice_global_mesh = Mesh(device_mesh, [&#39;replica&#39;, &#39;data&#39;, &#39;model&#39;])
        logging.info(
            &#39;multi_slice_global_mesh axis_names: %s&#39;,
            multi_slice_global_mesh.axis_names,
        )
        logging.info(
            &#39;multi_slice_global_mesh devices: %s&#39;, multi_slice_global_mesh.devices
        )
        logging.info(
            &#39;multi_slice_global_mesh devices shape: %s&#39;,
            multi_slice_global_mesh.devices.shape,
        )
        return multi_slice_global_mesh

    if model_parallel_submesh:
        return get_mesh(model_parallel_submesh, backend=backend)

    if platform == &#39;cpu&#39;:
        return get_cpu_mesh()
    elif platform == &#39;gpu&#39;:
        return get_gpu_mesh(num_partitions)

    mps = None
    if device_kind in (&#39;TPU v2&#39;, &#39;TPU v3&#39;):
        if num_partitions == 1:
            mps = (1, 1, 1, 1)
        elif num_partitions == 2:
            mps = (1, 1, 1, 2)
        elif num_partitions == 4:
            mps = (2, 1, 1, 2)
        elif num_partitions == 8:
            mps = (2, 2, 1, 2)
        elif num_partitions == 16:
            mps = (4, 2, 1, 2)
    # assume the use of megacore on TPU v4
    elif (device_kind == &#39;TPU v4&#39; or
          device_kind == &#39;TPU v4 lite&#39;) and bounds[3] == 1:
        if num_partitions == 1:
            mps = (1, 1, 1, 1)
        elif num_partitions == 2:
            mps = (1, 2, 1, 1)
        elif num_partitions == 4:
            if bounds[0] &gt;= 4:
                mps = (4, 1, 1, 1)
            else:
                mps = (2, 2, 1, 1)
        elif num_partitions == 8:
            if bounds[2] &gt;= 8:
                mps = (1, 1, 8, 1)
            else:
                mps = (4, 2, 1, 1)
        elif num_partitions == 16:
            if bounds[2] &gt;= 16:
                mps = (1, 1, 16, 1)
            elif bounds[0] &gt;= 8:
                mps = (8, 2, 1, 1)
            elif bounds[0] &gt;= 4:
                mps = (4, 4, 1, 1)
            else:
                mps = (2, 2, 4, 1)

    if mps is None:
        raise ValueError(
            &#39;No default mesh for this configuration: specify &#39;
            &#39;config.model_parallel_submesh explicitly. \n&#39;
            f&#39;Platform: {platform}\n&#39;
            f&#39;Device kind: {device_kind}\n&#39;
            f&#39;Num partitions: {num_partitions}\n&#39;
            f&#39;Bounds: {bounds}&#39;
        )
    return get_mesh(mps, backend=backend)</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.get_coords"><code class="name flex">
<span>def <span class="ident">get_coords</span></span>(<span>device:jaxlib.xla_extension.Device) >Union[Tuple[int,int,int,int],Tuple[int,int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the coordinates of the given device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coords(device: jax.Device) -&gt; HardwareMesh:
    &#34;&#34;&#34;Returns the coordinates of the given device.&#34;&#34;&#34;
    if hasattr(device, &#39;coords&#39;):
        return *device.coords, device.core_on_chip
    return device.process_index, device.id % jax.local_device_count()</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.get_cpu_mesh"><code class="name flex">
<span>def <span class="ident">get_cpu_mesh</span></span>(<span>) >jax._src.mesh.Mesh</span>
</code></dt>
<dd>
<div class="desc"><p>Trivial mesh for CPU Testing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cpu_mesh() -&gt; Mesh:
    &#34;&#34;&#34;Trivial mesh for CPU Testing.&#34;&#34;&#34;
    devices = np.empty(
        (jax.process_count(), jax.local_device_count()), dtype=object
    )
    for device in jax.devices():
        devices[device.process_index, device.id % jax.local_device_count()] = device
    return Mesh(devices, [&#39;data&#39;, &#39;model&#39;])</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.get_gpu_mesh"><code class="name flex">
<span>def <span class="ident">get_gpu_mesh</span></span>(<span>num_partitions:int) >jax._src.mesh.Mesh</span>
</code></dt>
<dd>
<div class="desc"><p>Mesh for GPUs that preferentially places 'model' on NVLink.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gpu_mesh(num_partitions: int) -&gt; Mesh:
    &#34;&#34;&#34;Mesh for GPUs that preferentially places &#39;model&#39; on NVLink.&#34;&#34;&#34;
    nvlink_size = jax.local_device_count()
    dcn_size = jax.process_count()
    nvlink_mp = min(num_partitions, nvlink_size)
    nvlink_dp, extra1 = divmod(nvlink_size, nvlink_mp)
    dcn_mp, extra2 = divmod(num_partitions, nvlink_mp)
    assert not (extra1 or extra2), (&#39;number of partitions on GPU must be a factor&#39;
                                    &#39; or multiple of the number of local devices&#39;)
    dcn_dp = dcn_size // dcn_mp

    devices = create_hybrid_device_mesh(
        mesh_shape=[nvlink_dp, nvlink_mp],
        dcn_mesh_shape=[dcn_dp, dcn_mp],
        process_is_granule=True)

    global_mesh = Mesh(devices, [&#39;data&#39;, &#39;model&#39;])
    logging.info(&#39;global_mesh axis_names: %s&#39;, global_mesh.axis_names)
    logging.info(&#39;global_mesh devices: %s&#39;, global_mesh.devices)
    return global_mesh</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.get_mesh"><code class="name flex">
<span>def <span class="ident">get_mesh</span></span>(<span>model_parallel_submesh:Union[Tuple[int,int,int,int],Tuple[int,int]], input_devices:Sequence[jaxlib.xla_extension.Device]=(), input_local_devices:Sequence[jaxlib.xla_extension.Device]=(), tile_by_host_if_needed:bool=True, backend:Optional[str]=None) >jax._src.mesh.Mesh</span>
</code></dt>
<dd>
<div class="desc"><p>Construct an xmap/pjit Mesh for the given model-parallel submesh.</p>
<p>The resulting mesh has two resource axes: 'model', with the provided submesh
shape, and 'data', which covers the rest of the mesh.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_parallel_submesh</code></strong></dt>
<dd>a HardwareMesh spec, namely (x,y,z,core) on TPU for
a single model-parallel replica's "tile" in the physical device mesh. The
first three elements (<code>x</code>, <code>y</code>, and <code>z</code>) should be factors of the pod
slice; e.g., if you are using df_4x8, then <code>x</code> should be a factor of 4
(one of 1, 2, 4), <code>y</code> should be a factor of 8 (one of 1, 2, 4, 8), and <code>z</code>
must be 1, because TPU v3 slices are only 2D. <code>z</code> can be &gt;1 for TPU v4
(and maybe later TPUs) that allow 3D slices. <code>core</code> is the number of cores
to use from each TPU node. As communication is usually fastest inside the
same node, if you need a tile of more than 1 core, then
you should first increase <code>core</code>: e.g., for TPU v3, (1,1,1,2) is better
than (2,1,1,1). To pick a good spec, try a few possible values until you
get high TPU utilization.</dd>
<dt><strong><code>input_devices</code></strong></dt>
<dd>the devices to use, will use jax.devices() if this is not
set.</dd>
<dt><strong><code>input_local_devices</code></strong></dt>
<dd>the local devices to use, will use jax.local_devices()
if this is not set.</dd>
<dt><strong><code>tile_by_host_if_needed</code></strong></dt>
<dd>JAX currently requires that the parts of any sharded
array that are located on one host's local devices form a single
contiguous slice. A best effort will be made to achieve this without
"tiling" the device assignment over hosts (which can reduce XLA collective
performance). If this flag is True, then the device assignment will be
tiled over hosts if necessary to satisfy this constraint and create a
buildable mesh; if false, mesh construction will fail instead.</dd>
<dt><strong><code>backend</code></strong></dt>
<dd>get devices from the pinned backend, if specified. This is
useful for explicitly specifying the devices other than relying on
jax_platform_name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A xmap / pjit Mesh containing the virtual device mesh with data, model axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mesh(model_parallel_submesh: HardwareMesh,
             input_devices: Sequence[JaxDevice] = (),
             input_local_devices: Sequence[JaxDevice] = (),
             tile_by_host_if_needed: bool = True,
             backend: Optional[str] = None) -&gt; Mesh:
    &#34;&#34;&#34;Construct an xmap/pjit Mesh for the given model-parallel submesh.
  
    The resulting mesh has two resource axes: &#39;model&#39;, with the provided submesh
    shape, and &#39;data&#39;, which covers the rest of the mesh.
  
    Args:
      model_parallel_submesh: a HardwareMesh spec, namely (x,y,z,core) on TPU for
        a single model-parallel replica&#39;s &#34;tile&#34; in the physical device mesh. The
        first three elements (`x`, `y`, and `z`) should be factors of the pod
        slice; e.g., if you are using df_4x8, then `x` should be a factor of 4
        (one of 1, 2, 4), `y` should be a factor of 8 (one of 1, 2, 4, 8), and `z`
        must be 1, because TPU v3 slices are only 2D. `z` can be &gt;1 for TPU v4
        (and maybe later TPUs) that allow 3D slices. `core` is the number of cores
        to use from each TPU node. As communication is usually fastest inside the
        same node, if you need a tile of more than 1 core, then
        you should first increase `core`: e.g., for TPU v3, (1,1,1,2) is better
          than (2,1,1,1). To pick a good spec, try a few possible values until you
          get high TPU utilization.
      input_devices: the devices to use, will use jax.devices() if this is not
        set.
      input_local_devices: the local devices to use, will use jax.local_devices()
        if this is not set.
      tile_by_host_if_needed: JAX currently requires that the parts of any sharded
        array that are located on one host&#39;s local devices form a single
        contiguous slice. A best effort will be made to achieve this without
        &#34;tiling&#34; the device assignment over hosts (which can reduce XLA collective
        performance). If this flag is True, then the device assignment will be
        tiled over hosts if necessary to satisfy this constraint and create a
        buildable mesh; if false, mesh construction will fail instead.
      backend: get devices from the pinned backend, if specified. This is
        useful for explicitly specifying the devices other than relying on
        jax_platform_name.
  
    Returns:
      A xmap / pjit Mesh containing the virtual device mesh with data, model axes.
    &#34;&#34;&#34;
    input_devices = input_devices or jax.devices(backend)
    input_local_devices = input_local_devices or jax.local_devices(0, backend)
    # Sort input_devices based on coords, as backends might not return devices
    # in order.
    last_device = sorted(input_devices, key=get_coords)[-1]
    last_input_local_devices = sorted(input_local_devices, key=get_coords)[-1]
    logging.info(&#39;last device coords : %r\nlast local device coords: %r&#39;,
                 get_coords(last_device), get_coords(last_input_local_devices))
    global_hardware_mesh = bounds_from_last_device(last_device)
    mesh_ndim = len(global_hardware_mesh)
    local_hardware_mesh = bounds_from_last_device(last_input_local_devices)
    mesh_err = (
        f&#39;each dimension of the model parallel submesh {model_parallel_submesh} &#39;
        &#39;must be a factor of the corresponding dimension of the global device &#39;
        f&#39;mesh {global_hardware_mesh}&#39;)
    assert not any(
        g % m
        for g, m in zip(global_hardware_mesh, model_parallel_submesh)), mesh_err
    assert not any(
        g % l for g, l in zip(global_hardware_mesh, local_hardware_mesh))
    devices = np.empty(global_hardware_mesh, dtype=object)
    for device in input_devices:
        device_coords = get_coords(device)
        devices[device_coords] = device
    tile_by_host = tile_by_host_if_needed
    if len(global_hardware_mesh) == 4:
        # enable contiguous local chunks without host tiling by making Z major
        global_hardware_mesh = typing.cast(Tuple[int, int, int, int],
                                           global_hardware_mesh)
        model_parallel_submesh = typing.cast(Tuple[int, int, int, int],
                                             model_parallel_submesh)
        gx, gy, gz, gc = global_hardware_mesh
        mx, my, mz, mc = model_parallel_submesh
        if (mx == gx &gt; 1 and my == mz == 1) or (mx == 1 and my == gy &gt; 1 and
                                                mz == gz &gt; 1):
            logging.info(&#39;ensuring YZ plane has a Z-major device order&#39;)
            # YZ should be ZY
            assert mc == gc, (mc, gc)
            global_hardware_mesh = gx, gz, gy, gc
            model_parallel_submesh = mx, mz, my, mc
            devices = devices.swapaxes(1, 2)
            tile_by_host = False
        if (my == gy &gt; 1 and mx == mz == 1) or (my == 1 and mx == gx &gt; 1 and
                                                mz == gz &gt; 1):
            logging.info(&#39;ensuring XZ plane has a Z-major device order&#39;)
            # XZ should be ZX
            assert mc == gc, (mc, gc)
            global_hardware_mesh = gz, gy, gx, gc
            model_parallel_submesh = mz, my, mx, mc
            devices = devices.swapaxes(0, 2)
            tile_by_host = False
    if tile_by_host:
        logging.warning(
            &#39;Tiling device assignment mesh by hosts, which may lead to &#39;
            &#39;reduced XLA collective performance. To avoid this, modify &#39;
            &#39;the model parallel submesh or run with more tasks per host.&#39;)
        tile_err = (
            &#39;to tile the mesh by hosts, each dimension of the model parallel &#39;
            &#39;submesh must be either a factor or a multiple of the corresponding &#39;
            &#39;dimension of the per-host submesh&#39;)

        def dh_dd_mh_md(g: int, m: int, l: int) -&gt; Tuple[int, int, int, int]:
            &#34;&#34;&#34;Split a global mesh dimension into four tiling components.
      
            Args:
              g: global mesh bounds dimension size
              m: model-parallel submesh bounds dimension size
              l: local submesh bounds dimension size
      
            Returns:
              The resulting tuple divides the dimension into the hosts component of
              the data-parallel submesh, the devices component of the data-parallel
              submesh, the hosts component of the model-parallel submesh, and the
              devices component of the model-parallel submesh.
            &#34;&#34;&#34;
            d = g // m
            if m &gt;= l:
                assert not m % l, tile_err
                return d, 1, m // l, l
            else:
                assert not l % m, tile_err
                return d // (l // m), l // m, 1, m

        dh_dd_mh_md_tups = map(dh_dd_mh_md, global_hardware_mesh,
                               model_parallel_submesh, local_hardware_mesh)
        devices = devices.reshape(*(s for t in dh_dd_mh_md_tups for s in t))
        devices = devices.transpose(*(4 * i for i in range(mesh_ndim)),
                                    *(4 * i + 1 for i in range(mesh_ndim)),
                                    *(4 * i + 2 for i in range(mesh_ndim)),
                                    *(4 * i + 3 for i in range(mesh_ndim)))
    else:
        model_data_tups = [
            (g // m, m)
            for g, m in zip(global_hardware_mesh, model_parallel_submesh)
        ]
        devices = devices.reshape(*(s for t in model_data_tups for s in t))
        devices = devices.transpose(*(2 * i for i in range(mesh_ndim)),
                                    *(2 * i + 1 for i in range(mesh_ndim)))
    # reshape to (data, model)
    devices = devices.reshape(-1, np.prod(model_parallel_submesh))
    global_mesh = Mesh(devices, [&#39;data&#39;, &#39;model&#39;])
    logging.info(&#39;global_mesh axis_names: %s&#39;, global_mesh.axis_names)
    logging.info(&#39;global_mesh devices: %s&#39;, global_mesh.devices)
    logging.info(&#39;global_mesh devices shape: %s&#39;, global_mesh.devices.shape)
    return global_mesh</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.global_mesh_defined"><code class="name flex">
<span>def <span class="ident">global_mesh_defined</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if global xmap/pjit mesh resource environment is defined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_mesh_defined():
    &#34;&#34;&#34;Checks if global xmap/pjit mesh resource environment is defined.&#34;&#34;&#34;
    maps_env = jax.experimental.maps.thread_resources.env
    return maps_env.physical_mesh.devices.shape != ()  # pylint: disable=g-explicit-bool-comparison</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.host_local_array_to_global_array"><code class="name flex">
<span>def <span class="ident">host_local_array_to_global_array</span></span>(<span>arr_tree, mesh:jax._src.mesh.Mesh, pspecs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def host_local_array_to_global_array(arr_tree, mesh: jax.sharding.Mesh, pspecs):
    pspecs = jax.tree_map(
        lambda x: PartitionSpec() if x is None else x,
        pspecs,
        is_leaf=lambda x: x is None,
    )
    return multihost_utils.host_local_array_to_global_array(
        arr_tree, mesh, pspecs
    )</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.standard_logical_axis_rules"><code class="name flex">
<span>def <span class="ident">standard_logical_axis_rules</span></span>(<span>activation_partitioning_dims:int=1, parameter_partitioning_dims:int=1, additional_rules:Optional[Sequence[Tuple[str,Optional[str]]]]=None) >Sequence[Tuple[str,Optional[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Default sharding rules for T5X model in terms of logical axis names.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>activation_partitioning_dims</code></strong></dt>
<dd>enables 2-D activation sharding when set to 2.</dd>
<dt><strong><code>parameter_partitioning_dims</code></strong></dt>
<dd>enables 2-D parameter sharding when set to 2.</dd>
<dt><strong><code>additional_rules</code></strong></dt>
<dd>additional rules (a sequence of tuples) that will be
appended to the standard rules.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sequence of logical axis rules</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def standard_logical_axis_rules(
        activation_partitioning_dims: int = 1,
        parameter_partitioning_dims: int = 1,
        additional_rules: Optional[LogicalAxisRules] = None) -&gt; LogicalAxisRules:
    &#34;&#34;&#34;Default sharding rules for T5X model in terms of logical axis names.
  
    Args:
      activation_partitioning_dims: enables 2-D activation sharding when set to 2.
      parameter_partitioning_dims: enables 2-D parameter sharding when set to 2.
      additional_rules: additional rules (a sequence of tuples) that will be
        appended to the standard rules.
  
    Returns:
      Sequence of logical axis rules
    &#34;&#34;&#34;
    logging.info(
        &#39;`activation_partitioning_dims` = %d, `parameter_partitioning_dims` = %d&#39;,
        activation_partitioning_dims, parameter_partitioning_dims)

    if activation_partitioning_dims == 1 and parameter_partitioning_dims == 1:
        rules = [
            (&#39;batch&#39;, &#39;data&#39;),
            (&#39;vocab&#39;, &#39;model&#39;),
            (&#39;embed&#39;, None),
            (&#39;mlp&#39;, &#39;model&#39;),
            (&#39;heads&#39;, &#39;model&#39;),
            (&#39;kv&#39;, None),
            (&#39;joined_kv&#39;, &#39;model&#39;),  # joined heads+kv dim in 2D attn param layouts
        ]
    elif activation_partitioning_dims == 2 and parameter_partitioning_dims == 1:
        rules = [
            (&#39;batch&#39;, &#39;data&#39;),
            (&#39;vocab&#39;, &#39;model&#39;),
            (&#39;mlp&#39;, &#39;model&#39;),
            (&#39;heads&#39;, &#39;model&#39;),
            (&#39;kv&#39;, None),
            (&#39;joined_kv&#39;, &#39;model&#39;),
            (&#39;embed&#39;, &#39;model&#39;),
        ]
    elif activation_partitioning_dims == 1 and parameter_partitioning_dims == 2:
        rules = [
            (&#39;batch&#39;, &#39;data&#39;),
            (&#39;vocab&#39;, &#39;model&#39;),
            (&#39;mlp&#39;, &#39;model&#39;),
            (&#39;heads&#39;, &#39;model&#39;),
            (&#39;kv&#39;, None),
            (&#39;joined_kv&#39;, &#39;model&#39;),
            (&#39;embed&#39;, &#39;data&#39;),
        ]
    elif activation_partitioning_dims == 2 and parameter_partitioning_dims == 2:
        rules = [
            (&#39;batch&#39;, &#39;data&#39;),
            (&#39;vocab&#39;, &#39;model&#39;),
            (&#39;mlp&#39;, &#39;model&#39;),
            (&#39;heads&#39;, &#39;model&#39;),
            (&#39;kv&#39;, None),
            (&#39;joined_kv&#39;, &#39;model&#39;),
            (&#39;embed&#39;, &#39;model&#39;),
            (&#39;embed&#39;, &#39;data&#39;),
        ]
    else:
        raise ValueError(
            f&#39;`activation_partitioning_dims` = {activation_partitioning_dims} &#39;
            f&#39;`parameter_partitioning_dims` = {parameter_partitioning_dims} &#39;
            &#39;is not supported.&#39;)

    # Add the common rules for the replicated logical axes names.
    replicated_rules = [
        (&#39;relpos_buckets&#39;, None),
        (&#39;abspos_buckets&#39;, None),
        (&#39;length&#39;, None),
        (&#39;layers&#39;, None),
        (&#39;stack&#39;, None),
        (&#39;mlp_activations&#39;, None),
    ]
    rules.extend(replicated_rules)

    if additional_rules:
        rules.extend(additional_rules)

    return rules</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.with_sharding_constraint"><code class="name flex">
<span>def <span class="ident">with_sharding_constraint</span></span>(<span>x, axis_resources)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for lax.with_sharding_constraint, no-op on cpu or outside pjit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_sharding_constraint(x, axis_resources):
    &#34;&#34;&#34;Wrapper for lax.with_sharding_constraint, no-op on cpu or outside pjit.&#34;&#34;&#34;
    if jax.devices()[0].platform == &#39;cpu&#39; or not global_mesh_defined():
        return x
    else:
        return jax.lax.with_sharding_constraint(x, axis_resources)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.AxisNames"><code class="flex name class">
<span>class <span class="ident">AxisNames</span></span>
<span>(</span><span>*names)</span>
</code></dt>
<dd>
<div class="desc"><p>Tuple of strings specifying name for each axis.</p>
<p>We create a separate class for this so JAX's pytree utilities can distinguish
it from a tuple that should be treated as a pytree, instead treating it as a
leaf.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AxisNames(tuple):
    &#34;&#34;&#34;Tuple of strings specifying name for each axis.
  
    We create a separate class for this so JAX&#39;s pytree utilities can distinguish
    it from a tuple that should be treated as a pytree, instead treating it as a
    leaf.
    &#34;&#34;&#34;

    def __new__(cls, *names):
        return tuple.__new__(AxisNames, names)

    def __repr__(self):
        return &#39;AxisNames%s&#39; % tuple.__repr__(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner"><code class="flex name class">
<span>class <span class="ident">BasePartitioner</span></span>
<span>(</span><span>num_partitions:int|None=None, model_parallel_submesh:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None, params_on_devices:bool=True, backend:Optional[str]=None, ici_mesh_shape:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None, dcn_mesh_shape:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Interface for partitioning computations across hardware devices.</p>
<p>Configures the partitioner.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_partitions</code></strong></dt>
<dd>the number of partitions to use. Ignored if
<code>model_parallel_submesh</code> is provided.</dd>
<dt><strong><code>model_parallel_submesh</code></strong></dt>
<dd>4-tuple that specifies the x,y,z,c submesh to use
as the model-parallel device tile. This submesh is used for the larger
of the two parameter dimensions, and, if 2-D activation sharding is
enabled, for the model dimension of activations. The rest of the mesh is
used for data parallelism and, if 2-D parameter sharding is enabled, the
other parameter dimension.</dd>
<dt><strong><code>params_on_devices</code></strong></dt>
<dd>whether to keep the params on devices, if False -
params stay in the host memory. Note that some partitioners might ignore
this setting, for example if they don't support storing all params on
device memory.</dd>
<dt><strong><code>backend</code></strong></dt>
<dd>get devices from the pinned backend, if specified. This is useful
for explicitly specifying the devices other than relying on
jax_platform_name.</dd>
<dt><strong><code>ici_mesh_shape</code></strong></dt>
<dd>Shape of the logical mesh used for SPMD parallelism in
each slice. The meaning of each mesh axis is defined by mesh_axis_names,
so these two params must be the same length. If dcn_mesh_shape is
present, the overall mesh is the product of ici_mesh_shape and
dcn_mesh_shape. For example, an ici_mesh_shape of [2, 3, 4] with
mesh_axis_names ['replica', 'data', 'mdl'] indicates 2-way replica
parallelism, 3-way data parallelism, and 4-way model parallelism over 24
devices. None, the default, is equivalent to a sequence of ones and
means that the model is placed on a single device.</dd>
<dt><strong><code>dcn_mesh_shape</code></strong></dt>
<dd>Shape of the logical mesh used for SPMD parallelism over
multiple slices. The overall mesh is the product of ici_mesh_shape and
dcn_mesh_shape, and the meaning of each mesh axis is defined by
mesh_axis_names, so these three params must be the same length.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasePartitioner(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Interface for partitioning computations across hardware devices.&#34;&#34;&#34;

    def __init__(
            self,
            num_partitions: Optional[int] = None,
            model_parallel_submesh: Optional[HardwareMesh] = None,
            params_on_devices: bool = True,
            backend: Optional[str] = None,
            ici_mesh_shape: Optional[HardwareMesh] = None,
            dcn_mesh_shape: Optional[HardwareMesh] = None,
    ):
        &#34;&#34;&#34;Configures the partitioner.
    
        Args:
          num_partitions: the number of partitions to use. Ignored if
            `model_parallel_submesh` is provided.
          model_parallel_submesh: 4-tuple that specifies the x,y,z,c submesh to use
            as the model-parallel device tile. This submesh is used for the larger
            of the two parameter dimensions, and, if 2-D activation sharding is
            enabled, for the model dimension of activations. The rest of the mesh is
            used for data parallelism and, if 2-D parameter sharding is enabled, the
            other parameter dimension.
          params_on_devices: whether to keep the params on devices, if False -
            params stay in the host memory. Note that some partitioners might ignore
            this setting, for example if they don&#39;t support storing all params on
            device memory.
          backend: get devices from the pinned backend, if specified. This is useful
            for explicitly specifying the devices other than relying on
            jax_platform_name.
          ici_mesh_shape: Shape of the logical mesh used for SPMD parallelism in
            each slice. The meaning of each mesh axis is defined by mesh_axis_names,
            so these two params must be the same length. If dcn_mesh_shape is
            present, the overall mesh is the product of ici_mesh_shape and
            dcn_mesh_shape. For example, an ici_mesh_shape of [2, 3, 4] with
            mesh_axis_names [&#39;replica&#39;, &#39;data&#39;, &#39;mdl&#39;] indicates 2-way replica
            parallelism, 3-way data parallelism, and 4-way model parallelism over 24
            devices. None, the default, is equivalent to a sequence of ones and
            means that the model is placed on a single device.
          dcn_mesh_shape: Shape of the logical mesh used for SPMD parallelism over
            multiple slices. The overall mesh is the product of ici_mesh_shape and
            dcn_mesh_shape, and the meaning of each mesh axis is defined by
            mesh_axis_names, so these three params must be the same length.
        &#34;&#34;&#34;

        if not num_partitions and not model_parallel_submesh:
            raise ValueError(&#39;At least one of `num_partitions` or &#39;
                             &#39;`model_parallel_submesh` must be set.&#39;)

        if model_parallel_submesh is not None and len(model_parallel_submesh) != 4:
            logging.error(
                (
                    &#39;`model_parallel_submesh` must be either None or a 4-tuple. Got&#39;
                    &#39; `model_parallel_submesh`=%r. A ValueError will be raised&#39;
                    &#39; beginning March 1, 2022.&#39;
                ),
                model_parallel_submesh,
            )

        if bool(num_partitions) and bool(model_parallel_submesh):
            logging.error(
                &#39;At most one of `num_partitions` or `model_parallel_submesh` can be &#39;
                &#39;set. Got `num_partitions=%r` and `model_parallel_submesh`=%r. A &#39;
                &#39;ValueError will be raised beginning March 21, 2022.&#39;,
                num_partitions,
                model_parallel_submesh,
            )

        self._num_partitions = num_partitions
        self._model_parallel_submesh = model_parallel_submesh
        self._params_on_devices = params_on_devices
        if ici_mesh_shape is None or dcn_mesh_shape is None:
            self._data_axis = &#39;data&#39;
        else:
            self._data_axis = (&#39;replica&#39;, &#39;data&#39;)
        self._backend = backend
        self._ici_mesh_shape = ici_mesh_shape
        self._dcn_mesh_shape = dcn_mesh_shape

    @property
    def mesh(self) -&gt; Mesh:
        raise NotImplementedError

    @property
    def data_partition_spec(self) -&gt; PartitionSpec:
        return PartitionSpec(self._data_axis)

    @property
    def data_mesh_size(self) -&gt; int:
        &#34;&#34;&#34;Data mesh size.
    
        Data mesh size is defined as the number of global devices involved to
        carry out data parallel. Let&#39;s say we have a global mesh: (&#39;replica&#39;: 2,
        &#39;data&#39;: 4, &#39;model&#39;: 2), and axes &#39;replica&#39; and &#39;data&#39; are responsible for
        the data parallel, that means we have 2*4 = 8 devices involved - i.e., data
        mesh size is 8.
    
        Returns:
          the id of the shard for the axes being replicated among the devices used
          to shard the sharded_mesh_axes.
        &#34;&#34;&#34;
        data_submesh_sizes = (
            [self.mesh.shape[self._data_axis]]
            if isinstance(self._data_axis, str)
            else [self.mesh.shape[axis] for axis in self._data_axis]
        )
        data_mesh_size = functools.reduce(lambda x, y: x * y, data_submesh_sizes)
        return data_mesh_size

    @property
    def data_shards(self) -&gt; int:
        &#34;&#34;&#34;Number of data shards.
    
        Let&#39;s say we are dealing with 2 slices of df4x2 TPUs. In data pipeline
        we need prepare / send one data shard to each local host. This means, we
        need 4 shards since we have 4 local hosts. How to infer the number of hosts
        from mesh information? In this case, we have a global mesh: (&#39;replica&#39;: 2,
        &#39;data&#39;: 8, &#39;model&#39;: 2). Each local host (i.e., df2x2) has this local mesh:
        (&#39;replica&#39;: 1, &#39;data&#39;: 4, &#39;model&#39;: 2). By dividing global mesh with local
        mesh, we can get the count of hosts.
    
        Returns:
          Number of data shards. Each shard will be sent to one local host.
        &#34;&#34;&#34;
        data_chunks = (
            [self._local_chunker.num_chunks[self._data_axis]]
            if isinstance(self._data_axis, str)
            else [self._local_chunker.num_chunks[axis] for axis in self._data_axis]
        )
        data_shards = functools.reduce(lambda x, y: x * y, data_chunks)
        return data_shards

    @property
    def data_shard_id(self) -&gt; int:
        &#34;&#34;&#34;Data shard id for the current host.
    
        Returns:
          Index of data shard that will be sent to the current local host.
        &#34;&#34;&#34;
        return self._local_chunker.get_shard_id(self._data_axis)

    def get_data_layout(
            self, batch_size: Optional[int] = None, host_index: Optional[int] = None
    ) -&gt; DataLayout:
        &#34;&#34;&#34;Returns filled `DataLayout` based on the partitioned model layout.
    
        Args:
          batch_size: if set, indicates the requested batch size. The exception will
            be raised if this batch size is not compatible with the layout. If not
            set, the batch size is inferred from the layout.
          host_index: indicates the host index to use for the calculations, if not
            set - use JAX-provided one. Should be in [0, num_hosts) interval and the
            order should match the order of corresponding CPU devices in
            `jax.devices()`.
    
        Returns:
          Filled `DataLayout` structure.
        &#34;&#34;&#34;
        if host_index is not None:
            raise NotImplementedError(&#39;Explicit host_index is not yet implemented.&#39;)
        if self._data_axis is None:
            return DataLayout(
                batch_size=batch_size,
                shard_id=0,
                num_shards=1,
                is_first_host_in_replica_set=(jax.process_index() == 0))

        batch_size = batch_size or self.data_mesh_size
        if batch_size % self.data_mesh_size:
            raise ValueError(
                f&#39;Batch size ({batch_size}) must be divisible by corresponding &#39;
                f&#39;data mesh size ({self.data_mesh_size}).&#39;
            )

        if batch_size % self.data_shards:
            raise ValueError(
                f&#39;Batch size ({batch_size}) must be divisible by number of &#39;
                f&#39;data shards ({self.data_shards}).&#39;
            )
        replica_id = self._local_chunker.get_replica_id(self._data_axis)
        return DataLayout(
            batch_size=int(batch_size),
            shard_id=int(self.data_shard_id),
            num_shards=int(self.data_shards),
            is_first_host_in_replica_set=(replica_id == 0),
        )

    def get_local_chunk_info(
            self, global_shape: Tuple[int, ...],
            mesh_axes: Sequence[Optional[str]]) -&gt; LocalChunkInfo:
        &#34;&#34;&#34;Returns the local chunk info for a given array shape and sharded axes.&#34;&#34;&#34;
        return self._local_chunker.get_local_chunk_info(global_shape, mesh_axes)

    @property
    def params_on_devices(self):
        return self._params_on_devices

    @params_on_devices.setter
    def params_on_devices(self, value):
        self._params_on_devices = value

    def move_params_to_devices(self, train_state,
                               train_state_axes):
        &#34;&#34;&#34;Moves the optimizer parameters to devices.&#34;&#34;&#34;
        p_id_fn = self.partition(
            _id_fn,
            in_axis_resources=(train_state_axes, None),
            out_axis_resources=(train_state_axes, None),
            donate_argnums=(0,))
        if jax.process_count() &gt; 1:
            train_state = host_local_array_to_global_array(
                train_state, self.mesh, train_state_axes
            )
        train_state, _ = p_id_fn(train_state, jnp.ones((), dtype=jnp.uint32))
        return train_state

    @property
    @abc.abstractmethod
    def _local_chunker(self):
        &#34;&#34;&#34;Returns the chunker that matches the parameters of this partitioner.&#34;&#34;&#34;
        raise NotImplementedError

    def get_logical_axes(self, train_state):
        &#34;&#34;&#34;Returns a copy of TrainState with Optional[AxisNames] as leaves.&#34;&#34;&#34;
        # By default, return None for the logical axes.
        return train_state.restore_state(
            jax.tree_map(lambda x: None, train_state.state_dict()))

    def get_mesh_axes(self, train_state):
        &#34;&#34;&#34;Returns a copy of TrainState with Optional[PartitionSpecs] as leaves.&#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def partition(
            self,
            fn: Callable,  # pylint: disable=g-bare-generic
            in_axis_resources,
            out_axis_resources,
            static_argnums: Union[int, Sequence[int]] = (),
            donate_argnums: Union[int, Sequence[int]] = ()
    ) -&gt; PartitionedCallable:
        raise NotImplementedError

    @abc.abstractmethod
    def compile(self, partitioned_fn: PartitionedCallable,
                *args) -&gt; CompiledPartitionedCallable:

        raise NotImplementedError</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner" href="#fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner">BasePjitPartitioner</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_mesh_size"><code class="name">var <span class="ident">data_mesh_size</span> :int</code></dt>
<dd>
<div class="desc"><p>Data mesh size.</p>
<p>Data mesh size is defined as the number of global devices involved to
carry out data parallel. Let's say we have a global mesh: ('replica': 2,
'data': 4, 'model': 2), and axes 'replica' and 'data' are responsible for
the data parallel, that means we have 2*4 = 8 devices involved - i.e., data
mesh size is 8.</p>
<h2 id="returns">Returns</h2>
<p>the id of the shard for the axes being replicated among the devices used
to shard the sharded_mesh_axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_mesh_size(self) -&gt; int:
    &#34;&#34;&#34;Data mesh size.

    Data mesh size is defined as the number of global devices involved to
    carry out data parallel. Let&#39;s say we have a global mesh: (&#39;replica&#39;: 2,
    &#39;data&#39;: 4, &#39;model&#39;: 2), and axes &#39;replica&#39; and &#39;data&#39; are responsible for
    the data parallel, that means we have 2*4 = 8 devices involved - i.e., data
    mesh size is 8.

    Returns:
      the id of the shard for the axes being replicated among the devices used
      to shard the sharded_mesh_axes.
    &#34;&#34;&#34;
    data_submesh_sizes = (
        [self.mesh.shape[self._data_axis]]
        if isinstance(self._data_axis, str)
        else [self.mesh.shape[axis] for axis in self._data_axis]
    )
    data_mesh_size = functools.reduce(lambda x, y: x * y, data_submesh_sizes)
    return data_mesh_size</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_partition_spec"><code class="name">var <span class="ident">data_partition_spec</span> :jax._src.partition_spec.PartitionSpec</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_partition_spec(self) -&gt; PartitionSpec:
    return PartitionSpec(self._data_axis)</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shard_id"><code class="name">var <span class="ident">data_shard_id</span> :int</code></dt>
<dd>
<div class="desc"><p>Data shard id for the current host.</p>
<h2 id="returns">Returns</h2>
<p>Index of data shard that will be sent to the current local host.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_shard_id(self) -&gt; int:
    &#34;&#34;&#34;Data shard id for the current host.

    Returns:
      Index of data shard that will be sent to the current local host.
    &#34;&#34;&#34;
    return self._local_chunker.get_shard_id(self._data_axis)</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shards"><code class="name">var <span class="ident">data_shards</span> :int</code></dt>
<dd>
<div class="desc"><p>Number of data shards.</p>
<p>Let's say we are dealing with 2 slices of df4x2 TPUs. In data pipeline
we need prepare / send one data shard to each local host. This means, we
need 4 shards since we have 4 local hosts. How to infer the number of hosts
from mesh information? In this case, we have a global mesh: ('replica': 2,
'data': 8, 'model': 2). Each local host (i.e., df2x2) has this local mesh:
('replica': 1, 'data': 4, 'model': 2). By dividing global mesh with local
mesh, we can get the count of hosts.</p>
<h2 id="returns">Returns</h2>
<p>Number of data shards. Each shard will be sent to one local host.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_shards(self) -&gt; int:
    &#34;&#34;&#34;Number of data shards.

    Let&#39;s say we are dealing with 2 slices of df4x2 TPUs. In data pipeline
    we need prepare / send one data shard to each local host. This means, we
    need 4 shards since we have 4 local hosts. How to infer the number of hosts
    from mesh information? In this case, we have a global mesh: (&#39;replica&#39;: 2,
    &#39;data&#39;: 8, &#39;model&#39;: 2). Each local host (i.e., df2x2) has this local mesh:
    (&#39;replica&#39;: 1, &#39;data&#39;: 4, &#39;model&#39;: 2). By dividing global mesh with local
    mesh, we can get the count of hosts.

    Returns:
      Number of data shards. Each shard will be sent to one local host.
    &#34;&#34;&#34;
    data_chunks = (
        [self._local_chunker.num_chunks[self._data_axis]]
        if isinstance(self._data_axis, str)
        else [self._local_chunker.num_chunks[axis] for axis in self._data_axis]
    )
    data_shards = functools.reduce(lambda x, y: x * y, data_chunks)
    return data_shards</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.mesh"><code class="name">var <span class="ident">mesh</span> :jax._src.mesh.Mesh</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mesh(self) -&gt; Mesh:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.params_on_devices"><code class="name">var <span class="ident">params_on_devices</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def params_on_devices(self):
    return self._params_on_devices</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self, partitioned_fn:Callable[...,Any], *args) >Callable[...,Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def compile(self, partitioned_fn: PartitionedCallable,
            *args) -&gt; CompiledPartitionedCallable:

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_data_layout"><code class="name flex">
<span>def <span class="ident">get_data_layout</span></span>(<span>self, batch_size:int|None=None, host_index:int|None=None) ><a title="fjformer.partition_utils.t5x_partitioning.DataLayout" href="#fjformer.partition_utils.t5x_partitioning.DataLayout">DataLayout</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns filled <code><a title="fjformer.partition_utils.t5x_partitioning.DataLayout" href="#fjformer.partition_utils.t5x_partitioning.DataLayout">DataLayout</a></code> based on the partitioned model layout.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>batch_size</code></strong></dt>
<dd>if set, indicates the requested batch size. The exception will
be raised if this batch size is not compatible with the layout. If not
set, the batch size is inferred from the layout.</dd>
<dt><strong><code>host_index</code></strong></dt>
<dd>indicates the host index to use for the calculations, if not
set - use JAX-provided one. Should be in [0, num_hosts) interval and the
order should match the order of corresponding CPU devices in
<code>jax.devices()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Filled <code><a title="fjformer.partition_utils.t5x_partitioning.DataLayout" href="#fjformer.partition_utils.t5x_partitioning.DataLayout">DataLayout</a></code> structure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_layout(
        self, batch_size: Optional[int] = None, host_index: Optional[int] = None
) -&gt; DataLayout:
    &#34;&#34;&#34;Returns filled `DataLayout` based on the partitioned model layout.

    Args:
      batch_size: if set, indicates the requested batch size. The exception will
        be raised if this batch size is not compatible with the layout. If not
        set, the batch size is inferred from the layout.
      host_index: indicates the host index to use for the calculations, if not
        set - use JAX-provided one. Should be in [0, num_hosts) interval and the
        order should match the order of corresponding CPU devices in
        `jax.devices()`.

    Returns:
      Filled `DataLayout` structure.
    &#34;&#34;&#34;
    if host_index is not None:
        raise NotImplementedError(&#39;Explicit host_index is not yet implemented.&#39;)
    if self._data_axis is None:
        return DataLayout(
            batch_size=batch_size,
            shard_id=0,
            num_shards=1,
            is_first_host_in_replica_set=(jax.process_index() == 0))

    batch_size = batch_size or self.data_mesh_size
    if batch_size % self.data_mesh_size:
        raise ValueError(
            f&#39;Batch size ({batch_size}) must be divisible by corresponding &#39;
            f&#39;data mesh size ({self.data_mesh_size}).&#39;
        )

    if batch_size % self.data_shards:
        raise ValueError(
            f&#39;Batch size ({batch_size}) must be divisible by number of &#39;
            f&#39;data shards ({self.data_shards}).&#39;
        )
    replica_id = self._local_chunker.get_replica_id(self._data_axis)
    return DataLayout(
        batch_size=int(batch_size),
        shard_id=int(self.data_shard_id),
        num_shards=int(self.data_shards),
        is_first_host_in_replica_set=(replica_id == 0),
    )</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_local_chunk_info"><code class="name flex">
<span>def <span class="ident">get_local_chunk_info</span></span>(<span>self, global_shape:Tuple[int,...], mesh_axes:Sequence[Optional[str]]) ><a title="fjformer.partition_utils.t5x_partitioning.LocalChunkInfo" href="#fjformer.partition_utils.t5x_partitioning.LocalChunkInfo">LocalChunkInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the local chunk info for a given array shape and sharded axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_local_chunk_info(
        self, global_shape: Tuple[int, ...],
        mesh_axes: Sequence[Optional[str]]) -&gt; LocalChunkInfo:
    &#34;&#34;&#34;Returns the local chunk info for a given array shape and sharded axes.&#34;&#34;&#34;
    return self._local_chunker.get_local_chunk_info(global_shape, mesh_axes)</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_logical_axes"><code class="name flex">
<span>def <span class="ident">get_logical_axes</span></span>(<span>self, train_state)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of TrainState with Optional[AxisNames] as leaves.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_logical_axes(self, train_state):
    &#34;&#34;&#34;Returns a copy of TrainState with Optional[AxisNames] as leaves.&#34;&#34;&#34;
    # By default, return None for the logical axes.
    return train_state.restore_state(
        jax.tree_map(lambda x: None, train_state.state_dict()))</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_mesh_axes"><code class="name flex">
<span>def <span class="ident">get_mesh_axes</span></span>(<span>self, train_state)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of TrainState with Optional[PartitionSpecs] as leaves.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mesh_axes(self, train_state):
    &#34;&#34;&#34;Returns a copy of TrainState with Optional[PartitionSpecs] as leaves.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.move_params_to_devices"><code class="name flex">
<span>def <span class="ident">move_params_to_devices</span></span>(<span>self, train_state, train_state_axes)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the optimizer parameters to devices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_params_to_devices(self, train_state,
                           train_state_axes):
    &#34;&#34;&#34;Moves the optimizer parameters to devices.&#34;&#34;&#34;
    p_id_fn = self.partition(
        _id_fn,
        in_axis_resources=(train_state_axes, None),
        out_axis_resources=(train_state_axes, None),
        donate_argnums=(0,))
    if jax.process_count() &gt; 1:
        train_state = host_local_array_to_global_array(
            train_state, self.mesh, train_state_axes
        )
    train_state, _ = p_id_fn(train_state, jnp.ones((), dtype=jnp.uint32))
    return train_state</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePartitioner.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>self, fn:Callable, in_axis_resources, out_axis_resources, static_argnums:Union[int,Sequence[int]]=(), donate_argnums:Union[int,Sequence[int]]=()) >Callable[...,Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def partition(
        self,
        fn: Callable,  # pylint: disable=g-bare-generic
        in_axis_resources,
        out_axis_resources,
        static_argnums: Union[int, Sequence[int]] = (),
        donate_argnums: Union[int, Sequence[int]] = ()
) -&gt; PartitionedCallable:
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner"><code class="flex name class">
<span>class <span class="ident">BasePjitPartitioner</span></span>
<span>(</span><span>num_partitions:int|None=None, model_parallel_submesh:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None, params_on_devices:bool=True, backend:Optional[str]=None, ici_mesh_shape:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None, dcn_mesh_shape:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Partitioner that uses T5X version of jax.pjit.</p>
<p>Configures the partitioner.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_partitions</code></strong></dt>
<dd>the number of partitions to use. Ignored if
<code>model_parallel_submesh</code> is provided.</dd>
<dt><strong><code>model_parallel_submesh</code></strong></dt>
<dd>4-tuple that specifies the x,y,z,c submesh to use
as the model-parallel device tile. This submesh is used for the larger
of the two parameter dimensions, and, if 2-D activation sharding is
enabled, for the model dimension of activations. The rest of the mesh is
used for data parallelism and, if 2-D parameter sharding is enabled, the
other parameter dimension.</dd>
<dt><strong><code>params_on_devices</code></strong></dt>
<dd>whether to keep the params on devices, if False -
params stay in the host memory. Note that some partitioners might ignore
this setting, for example if they don't support storing all params on
device memory.</dd>
<dt><strong><code>backend</code></strong></dt>
<dd>get devices from the pinned backend, if specified. This is useful
for explicitly specifying the devices other than relying on
jax_platform_name.</dd>
<dt><strong><code>ici_mesh_shape</code></strong></dt>
<dd>Shape of the logical mesh used for SPMD parallelism in
each slice. The meaning of each mesh axis is defined by mesh_axis_names,
so these two params must be the same length. If dcn_mesh_shape is
present, the overall mesh is the product of ici_mesh_shape and
dcn_mesh_shape. For example, an ici_mesh_shape of [2, 3, 4] with
mesh_axis_names ['replica', 'data', 'mdl'] indicates 2-way replica
parallelism, 3-way data parallelism, and 4-way model parallelism over 24
devices. None, the default, is equivalent to a sequence of ones and
means that the model is placed on a single device.</dd>
<dt><strong><code>dcn_mesh_shape</code></strong></dt>
<dd>Shape of the logical mesh used for SPMD parallelism over
multiple slices. The overall mesh is the product of ici_mesh_shape and
dcn_mesh_shape, and the meaning of each mesh axis is defined by
mesh_axis_names, so these three params must be the same length.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasePjitPartitioner(BasePartitioner):
    &#34;&#34;&#34;Partitioner that uses T5X version of jax.pjit.&#34;&#34;&#34;

    @cached_property
    def _local_chunker(self) -&gt; LocalChunker:
        return LocalChunker(self.mesh)

    @cached_property
    def mesh(self) -&gt; Mesh:
        return default_mesh(
            self._num_partitions,
            self._model_parallel_submesh,
            self._backend,
            self._ici_mesh_shape,
            self._dcn_mesh_shape,
        )

    def partition(
            self,
            fn: Callable,  # pylint: disable=g-bare-generic
            in_axis_resources,
            out_axis_resources,
            static_argnums: Union[int, Sequence[int]] = (),
            donate_argnums: Union[int, Sequence[int]] = (),
    ) -&gt; PjittedFnWithContext:
        pjitted = pjit(
            fn,
            in_shardings=in_axis_resources,
            out_shardings=out_axis_resources,
            static_argnums=static_argnums,
            donate_argnums=donate_argnums,
        )

        return PjittedFnWithContext(pjitted, self.mesh)

    def compile(self, partitioned_fn: PjittedFnWithContext,
                *args) -&gt; CompiledPartitionedCallable:
        return partitioned_fn.lower(*args).compile()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner">BasePartitioner</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fjformer.partition_utils.t5x_partitioning.PjitPartitioner" href="#fjformer.partition_utils.t5x_partitioning.PjitPartitioner">PjitPartitioner</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.mesh"><code class="name">var <span class="ident">mesh</span> :jax._src.mesh.Mesh</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def mesh(self) -&gt; Mesh:
    return default_mesh(
        self._num_partitions,
        self._model_parallel_submesh,
        self._backend,
        self._ici_mesh_shape,
        self._dcn_mesh_shape,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self, partitioned_fn:<a title="fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext" href="#fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext">PjittedFnWithContext</a>, *args) >Callable[...,Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self, partitioned_fn: PjittedFnWithContext,
            *args) -&gt; CompiledPartitionedCallable:
    return partitioned_fn.lower(*args).compile()</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>self, fn:Callable, in_axis_resources, out_axis_resources, static_argnums:Union[int,Sequence[int]]=(), donate_argnums:Union[int,Sequence[int]]=()) ><a title="fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext" href="#fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext">PjittedFnWithContext</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(
        self,
        fn: Callable,  # pylint: disable=g-bare-generic
        in_axis_resources,
        out_axis_resources,
        static_argnums: Union[int, Sequence[int]] = (),
        donate_argnums: Union[int, Sequence[int]] = (),
) -&gt; PjittedFnWithContext:
    pjitted = pjit(
        fn,
        in_shardings=in_axis_resources,
        out_shardings=out_axis_resources,
        static_argnums=static_argnums,
        donate_argnums=donate_argnums,
    )

    return PjittedFnWithContext(pjitted, self.mesh)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner">BasePartitioner</a></b></code>:
<ul class="hlist">
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_mesh_size" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_mesh_size">data_mesh_size</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shard_id" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shard_id">data_shard_id</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shards" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shards">data_shards</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_data_layout" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_data_layout">get_data_layout</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_local_chunk_info" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_local_chunk_info">get_local_chunk_info</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_logical_axes" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_logical_axes">get_logical_axes</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_mesh_axes" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_mesh_axes">get_mesh_axes</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.move_params_to_devices" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.move_params_to_devices">move_params_to_devices</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.DataLayout"><code class="flex name class">
<span>class <span class="ident">DataLayout</span></span>
<span>(</span><span>batch_size:int, shard_id:int, num_shards:int, is_first_host_in_replica_set:bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents data layout for the partitioned model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class DataLayout:
    &#34;&#34;&#34;Represents data layout for the partitioned model.&#34;&#34;&#34;
    batch_size: int
    shard_id: int
    num_shards: int
    is_first_host_in_replica_set: bool</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.DataLayout.batch_size"><code class="name">var <span class="ident">batch_size</span> :int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.DataLayout.is_first_host_in_replica_set"><code class="name">var <span class="ident">is_first_host_in_replica_set</span> :bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.DataLayout.num_shards"><code class="name">var <span class="ident">num_shards</span> :int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.DataLayout.shard_id"><code class="name">var <span class="ident">shard_id</span> :int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.LocalChunkInfo"><code class="flex name class">
<span>class <span class="ident">LocalChunkInfo</span></span>
<span>(</span><span>slice:Tuple[slice,...], replica_id:int)</span>
</code></dt>
<dd>
<div class="desc"><p>LocalChunkInfo(slice: Tuple[slice, &hellip;], replica_id: int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class LocalChunkInfo:
    # The logical slice of an array located on this host&#39;s local devices.
    slice: Tuple[slice, ...]
    # A unique index for this host/local chunk among chunks with the same slice.
    replica_id: int</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.LocalChunkInfo.replica_id"><code class="name">var <span class="ident">replica_id</span> :int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.LocalChunkInfo.slice"><code class="name">var <span class="ident">slice</span> :Tuple[slice,...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.LocalChunker"><code class="flex name class">
<span>class <span class="ident">LocalChunker</span></span>
<span>(</span><span>global_mesh:jax._src.mesh.Mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility class to aid chunking of sharded arrays in multihost settings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalChunker:
    &#34;&#34;&#34;Utility class to aid chunking of sharded arrays in multihost settings.&#34;&#34;&#34;

    def __init__(self, global_mesh: Mesh):
        self.global_mesh = global_mesh
        local_mesh = global_mesh.local_mesh
        first_local_device = local_mesh.devices.reshape(-1)[0]
        host_location = collections.OrderedDict(
            zip(
                global_mesh.shape.keys(),
                list(zip(*np.nonzero(
                    global_mesh.devices == first_local_device)))[0]))
        self.num_chunks = collections.OrderedDict()
        self.chunk_ids = collections.OrderedDict()
        self.mesh_axes = list(global_mesh.shape.keys())
        for mesh_axis in self.mesh_axes:
            num_devices_per_chunk = local_mesh.shape[mesh_axis]
            self.num_chunks[mesh_axis] = (
                    global_mesh.shape[mesh_axis] // num_devices_per_chunk)
            self.chunk_ids[mesh_axis] = (
                    host_location[mesh_axis] // num_devices_per_chunk)

    def get_local_chunk_info(
            self, global_shape: Tuple[int, ...],
            mesh_axes: Sequence[Optional[str]]) -&gt; LocalChunkInfo:
        &#34;&#34;&#34;Get the local chunk info for a given array shape and sharded axes.
    
        Args:
          global_shape: the global, unsharded shape of the array to chunk.
          mesh_axes: a sequence of names (or None) of equal rank to `global_shape`
            that specifies which mesh dimensions the array is sharded along.
    
        Returns:
          LocalChunkInfo containing the logical slices of the array found on this
          host&#39;s local devices, as well as the replica index for this chunk among
          chunks with the same slice. The latter is used to determine which
          host should write this chunk during checkpointing.
        &#34;&#34;&#34;
        local_slice = [slice(None) for dim in global_shape]
        sharded_mesh_axes = set()
        for i, (mesh_axis, size) in enumerate(zip(mesh_axes, global_shape)):
            if not mesh_axis:
                continue
            sharded_mesh_axes.add(mesh_axis)
            if not isinstance(mesh_axis, str):
                raise NotImplementedError(&#39;TODO(jekbradbury)&#39;)
            chunk_id = self.chunk_ids[mesh_axis]
            chunk_size = size // self.num_chunks[mesh_axis]
            local_slice[i] = slice(chunk_id * chunk_size, (chunk_id + 1) * chunk_size)

        replica_id = self.get_replica_id(sharded_mesh_axes)

        return LocalChunkInfo(tuple(local_slice), replica_id)

    def get_shard_id(self, sharded_mesh_axes: str | Set[Optional[str]]) -&gt; int:
        &#34;&#34;&#34;Given mesh axes used for sharding, computes current host&#39;s shard id.
    
        To give an example, let&#39;s say there are two axes globally: replica, data,
        and model, the mesh axes for sharding is (&#39;replica&#39;, &#39;data&#39;), which means we
        are going to partition an array along &#39;replica&#39; and &#39;data&#39; axes.
        The shard_id is to show the index of the current local host along the
        sharding axes (in this example, it&#39;s &#39;replica&#39; and &#39;data&#39; axes).
    
        More concretely, let&#39;s say we have 4 local hosts, and we use &#39;replica&#39; and
        &#39;data&#39; axes for data parallel (2 hosts along the replica axis, and 2 host
        along the data axis). The host located in (&#39;replica&#39;: 0, &#39;data&#39;: 0), we
        should assign data shard-0 to it. For host (&#39;replica&#39;: 0, &#39;data&#39;: 1), we
        assign shard-1. For host (&#39;replica&#39;: 1, &#39;data&#39;: 0), we assign shard-2.
        For host (&#39;replica&#39;: 1, &#39;data&#39;: 1), we assign shard-3.
    
        Note: the host location along &#39;replica&#39; and &#39;data&#39; axes, e.g.,
        (&#39;replica&#39;: 0, &#39;data&#39;: 0) is named chunk_id and stored in
        self._local_chunker.chunk_ids[axis].
    
        Args:
          sharded_mesh_axes: the mesh axes for sharding.
    
        Returns:
          the index of the current local host along the sharding axes.
        &#34;&#34;&#34;
        if isinstance(sharded_mesh_axes, str):
            sharded_mesh_axes = (sharded_mesh_axes,)

        shard_id = 0
        for mesh_axis in sharded_mesh_axes:
            chunk_id = self.chunk_ids[mesh_axis]
            shard_id = shard_id * self.num_chunks[mesh_axis] + chunk_id

        return shard_id

    def get_replica_id(self, sharded_mesh_axes: str | Set[Optional[str]]) -&gt; int:
        &#34;&#34;&#34;Given mesh axes used for sharding, computes current host&#39;s replica id.
    
        To give an example, let&#39;s say there are two axes globally: data, and model,
        the mesh axes for sharding is (&#39;data&#39;, ), which means we are going to
        partition an array along &#39;data&#39; axis and replicate it along &#39;model&#39; axis.
        The replica_id is to show the index of the current local host along the
        &#39;model&#39; axis.
    
        Args:
          sharded_mesh_axes: the mesh axes for sharding.
    
        Returns:
          the index of the current local host along the non-sharding axes (i.e.,
          replicating axes).
        &#34;&#34;&#34;
        if isinstance(sharded_mesh_axes, str):
            sharded_mesh_axes = (sharded_mesh_axes,)

        replicated_mesh_axes = [
            mesh_axis for mesh_axis in self.mesh_axes
            if mesh_axis not in sharded_mesh_axes
        ]
        replica_id = 0
        for mesh_axis in replicated_mesh_axes:
            chunk_id = self.chunk_ids[mesh_axis]
            replica_id = replica_id * self.num_chunks[mesh_axis] + chunk_id

        return replica_id</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.LocalChunker.get_local_chunk_info"><code class="name flex">
<span>def <span class="ident">get_local_chunk_info</span></span>(<span>self, global_shape:Tuple[int,...], mesh_axes:Sequence[Optional[str]]) ><a title="fjformer.partition_utils.t5x_partitioning.LocalChunkInfo" href="#fjformer.partition_utils.t5x_partitioning.LocalChunkInfo">LocalChunkInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the local chunk info for a given array shape and sharded axes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>global_shape</code></strong></dt>
<dd>the global, unsharded shape of the array to chunk.</dd>
<dt><strong><code>mesh_axes</code></strong></dt>
<dd>a sequence of names (or None) of equal rank to <code>global_shape</code>
that specifies which mesh dimensions the array is sharded along.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>LocalChunkInfo containing the logical slices of the array found on this
host's local devices, as well as the replica index for this chunk among
chunks with the same slice. The latter is used to determine which
host should write this chunk during checkpointing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_local_chunk_info(
        self, global_shape: Tuple[int, ...],
        mesh_axes: Sequence[Optional[str]]) -&gt; LocalChunkInfo:
    &#34;&#34;&#34;Get the local chunk info for a given array shape and sharded axes.

    Args:
      global_shape: the global, unsharded shape of the array to chunk.
      mesh_axes: a sequence of names (or None) of equal rank to `global_shape`
        that specifies which mesh dimensions the array is sharded along.

    Returns:
      LocalChunkInfo containing the logical slices of the array found on this
      host&#39;s local devices, as well as the replica index for this chunk among
      chunks with the same slice. The latter is used to determine which
      host should write this chunk during checkpointing.
    &#34;&#34;&#34;
    local_slice = [slice(None) for dim in global_shape]
    sharded_mesh_axes = set()
    for i, (mesh_axis, size) in enumerate(zip(mesh_axes, global_shape)):
        if not mesh_axis:
            continue
        sharded_mesh_axes.add(mesh_axis)
        if not isinstance(mesh_axis, str):
            raise NotImplementedError(&#39;TODO(jekbradbury)&#39;)
        chunk_id = self.chunk_ids[mesh_axis]
        chunk_size = size // self.num_chunks[mesh_axis]
        local_slice[i] = slice(chunk_id * chunk_size, (chunk_id + 1) * chunk_size)

    replica_id = self.get_replica_id(sharded_mesh_axes)

    return LocalChunkInfo(tuple(local_slice), replica_id)</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.LocalChunker.get_replica_id"><code class="name flex">
<span>def <span class="ident">get_replica_id</span></span>(<span>self, sharded_mesh_axes:Union[str,Set[Optional[str]]]) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Given mesh axes used for sharding, computes current host's replica id.</p>
<p>To give an example, let's say there are two axes globally: data, and model,
the mesh axes for sharding is ('data', ), which means we are going to
partition an array along 'data' axis and replicate it along 'model' axis.
The replica_id is to show the index of the current local host along the
'model' axis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sharded_mesh_axes</code></strong></dt>
<dd>the mesh axes for sharding.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the index of the current local host along the non-sharding axes (i.e.,
replicating axes).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_replica_id(self, sharded_mesh_axes: str | Set[Optional[str]]) -&gt; int:
    &#34;&#34;&#34;Given mesh axes used for sharding, computes current host&#39;s replica id.

    To give an example, let&#39;s say there are two axes globally: data, and model,
    the mesh axes for sharding is (&#39;data&#39;, ), which means we are going to
    partition an array along &#39;data&#39; axis and replicate it along &#39;model&#39; axis.
    The replica_id is to show the index of the current local host along the
    &#39;model&#39; axis.

    Args:
      sharded_mesh_axes: the mesh axes for sharding.

    Returns:
      the index of the current local host along the non-sharding axes (i.e.,
      replicating axes).
    &#34;&#34;&#34;
    if isinstance(sharded_mesh_axes, str):
        sharded_mesh_axes = (sharded_mesh_axes,)

    replicated_mesh_axes = [
        mesh_axis for mesh_axis in self.mesh_axes
        if mesh_axis not in sharded_mesh_axes
    ]
    replica_id = 0
    for mesh_axis in replicated_mesh_axes:
        chunk_id = self.chunk_ids[mesh_axis]
        replica_id = replica_id * self.num_chunks[mesh_axis] + chunk_id

    return replica_id</code></pre>
</details>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.LocalChunker.get_shard_id"><code class="name flex">
<span>def <span class="ident">get_shard_id</span></span>(<span>self, sharded_mesh_axes:Union[str,Set[Optional[str]]]) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Given mesh axes used for sharding, computes current host's shard id.</p>
<p>To give an example, let's say there are two axes globally: replica, data,
and model, the mesh axes for sharding is ('replica', 'data'), which means we
are going to partition an array along 'replica' and 'data' axes.
The shard_id is to show the index of the current local host along the
sharding axes (in this example, it's 'replica' and 'data' axes).</p>
<p>More concretely, let's say we have 4 local hosts, and we use 'replica' and
'data' axes for data parallel (2 hosts along the replica axis, and 2 host
along the data axis). The host located in ('replica': 0, 'data': 0), we
should assign data shard-0 to it. For host ('replica': 0, 'data': 1), we
assign shard-1. For host ('replica': 1, 'data': 0), we assign shard-2.
For host ('replica': 1, 'data': 1), we assign shard-3.</p>
<p>Note: the host location along 'replica' and 'data' axes, e.g.,
('replica': 0, 'data': 0) is named chunk_id and stored in
self._local_chunker.chunk_ids[axis].</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sharded_mesh_axes</code></strong></dt>
<dd>the mesh axes for sharding.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the index of the current local host along the sharding axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shard_id(self, sharded_mesh_axes: str | Set[Optional[str]]) -&gt; int:
    &#34;&#34;&#34;Given mesh axes used for sharding, computes current host&#39;s shard id.

    To give an example, let&#39;s say there are two axes globally: replica, data,
    and model, the mesh axes for sharding is (&#39;replica&#39;, &#39;data&#39;), which means we
    are going to partition an array along &#39;replica&#39; and &#39;data&#39; axes.
    The shard_id is to show the index of the current local host along the
    sharding axes (in this example, it&#39;s &#39;replica&#39; and &#39;data&#39; axes).

    More concretely, let&#39;s say we have 4 local hosts, and we use &#39;replica&#39; and
    &#39;data&#39; axes for data parallel (2 hosts along the replica axis, and 2 host
    along the data axis). The host located in (&#39;replica&#39;: 0, &#39;data&#39;: 0), we
    should assign data shard-0 to it. For host (&#39;replica&#39;: 0, &#39;data&#39;: 1), we
    assign shard-1. For host (&#39;replica&#39;: 1, &#39;data&#39;: 0), we assign shard-2.
    For host (&#39;replica&#39;: 1, &#39;data&#39;: 1), we assign shard-3.

    Note: the host location along &#39;replica&#39; and &#39;data&#39; axes, e.g.,
    (&#39;replica&#39;: 0, &#39;data&#39;: 0) is named chunk_id and stored in
    self._local_chunker.chunk_ids[axis].

    Args:
      sharded_mesh_axes: the mesh axes for sharding.

    Returns:
      the index of the current local host along the sharding axes.
    &#34;&#34;&#34;
    if isinstance(sharded_mesh_axes, str):
        sharded_mesh_axes = (sharded_mesh_axes,)

    shard_id = 0
    for mesh_axis in sharded_mesh_axes:
        chunk_id = self.chunk_ids[mesh_axis]
        shard_id = shard_id * self.num_chunks[mesh_axis] + chunk_id

    return shard_id</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.PjitPartitioner"><code class="flex name class">
<span>class <span class="ident">PjitPartitioner</span></span>
<span>(</span><span>num_partitions:int|None=None, model_parallel_submesh:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None, params_on_devices:bool=True, backend:Optional[str]=None, ici_mesh_shape:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None, dcn_mesh_shape:Union[Tuple[int,int,int,int],Tuple[int,int],ForwardRef(None)]=None, logical_axis_rules:Optional[Sequence[Tuple[str,Optional[str]]]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Partitioner that uses named axes and jax.pjit.</p>
<p>PjitPartitioner constructor.</p>
<p>See <a href="https://github.com/google-research/text-to-text-transfer-transformer/blob/main/README.mdx/usage/partitioning">https://github.com/google-research/text-to-text-transfer-transformer/blob/main/README.mdx/usage/partitioning</a> for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_partitions</code></strong></dt>
<dd>an integer that specifies the size of the model parallel
submesh to be automatically selected for the current topology. See
<code>model_parallel_submesh</code> for details on how this submesh is used.
Mutually exclusive with <code>model_parallel_submesh</code>.</dd>
<dt><strong><code>model_parallel_submesh</code></strong></dt>
<dd>is a 4-tuple that specifies the <code>(x, y, z, c)</code>
submesh model-parallel device tile, an axis of accelerator parallelism
orthogonal to data parallelism. Array axes in a model's parameters or
activations can be sharded over this submesh using axis rules (see
<code>logical_axis_rules</code>) that map them to 'model'. The effective number of
model sub-partitions is equal to <code>np.prod(model_parallel_submesh)</code> and
must evenly divide the total number of devices (i.e.,
<code>jax.device_count() % np.prod(model_parallel_submesh) == 0</code>). The rest
of the TPU mesh is the data parallel submesh, providing
<code>jax.device_count() // np.prod(model_parallel_submesh)</code> partitions. It
is used for data (batch) parallelism and to shard other array axes that
are mapped to 'data'. This argument is mutually exclusive with
<code>num_partitions</code>.</dd>
<dt><strong><code>params_on_devices</code></strong></dt>
<dd>whether to keep the params on devices, if False -
params stay in the host memory. Note that some partitioners might ignore
this setting, for example if they don't support storing all params on
device memory.</dd>
<dt><strong><code>backend</code></strong></dt>
<dd>get devices from the pinned backend, if specified. This is useful
for explicitly specifying the devices other than relying on
jax_platform_name.</dd>
<dt><strong><code>ici_mesh_shape</code></strong></dt>
<dd>Shape of the logical mesh used for SPMD parallelism in
each slice. The meaning of each mesh axis is defined by mesh_axis_names,
so these two params must be the same length. If dcn_mesh_shape is
present, the overall mesh is the product of ici_mesh_shape and
dcn_mesh_shape. For example, an ici_mesh_shape of [2, 3, 4] with
mesh_axis_names ['replica', 'data', 'model'] indicates 2-way replica
parallelism, 3-way data parallelism, and 4-way model parallelism over 24
devices. None, the default, is equivalent to a sequence of ones and
means that the model is placed on a single device.</dd>
<dt><strong><code>dcn_mesh_shape</code></strong></dt>
<dd>Shape of the logical mesh used for SPMD parallelism over
multiple slices. The overall mesh is the product of ici_mesh_shape and
dcn_mesh_shape, and the meaning of each mesh axis is defined by
mesh_axis_names, so these three params must be the same length.</dd>
<dt><strong><code>logical_axis_rules</code></strong></dt>
<dd>a priority-ordered sequence of KV tuples that maps
logical axis names to either <code>None</code> (not sharded), 'model' (to shard
across the model-parallel submesh), or 'data' (to shard across the
data-parallel submesh).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PjitPartitioner(BasePjitPartitioner):
    &#34;&#34;&#34;Partitioner that uses named axes and jax.pjit.&#34;&#34;&#34;

    def __init__(
            self,
            num_partitions: Optional[int] = None,
            model_parallel_submesh: Optional[HardwareMesh] = None,
            params_on_devices: bool = True,
            backend: Optional[str] = None,
            ici_mesh_shape: Optional[HardwareMesh] = None,
            dcn_mesh_shape: Optional[HardwareMesh] = None,
            logical_axis_rules: Optional[LogicalAxisRules] = None,
    ):
        &#34;&#34;&#34;PjitPartitioner constructor.
    
        See https://github.com/google-research/text-to-text-transfer-transformer/blob/main/README.mdx/usage/partitioning for details.
    
        Args:
          num_partitions: an integer that specifies the size of the model parallel
            submesh to be automatically selected for the current topology. See
            `model_parallel_submesh` for details on how this submesh is used.
            Mutually exclusive with `model_parallel_submesh`.
          model_parallel_submesh: is a 4-tuple that specifies the `(x, y, z, c)`
            submesh model-parallel device tile, an axis of accelerator parallelism
            orthogonal to data parallelism. Array axes in a model&#39;s parameters or
            activations can be sharded over this submesh using axis rules (see
            `logical_axis_rules`) that map them to &#39;model&#39;. The effective number of
            model sub-partitions is equal to `np.prod(model_parallel_submesh)` and
            must evenly divide the total number of devices (i.e.,
            `jax.device_count() % np.prod(model_parallel_submesh) == 0`). The rest
            of the TPU mesh is the data parallel submesh, providing
            `jax.device_count() // np.prod(model_parallel_submesh)` partitions. It
            is used for data (batch) parallelism and to shard other array axes that
            are mapped to &#39;data&#39;. This argument is mutually exclusive with
            `num_partitions`.
          params_on_devices: whether to keep the params on devices, if False -
            params stay in the host memory. Note that some partitioners might ignore
            this setting, for example if they don&#39;t support storing all params on
            device memory.
          backend: get devices from the pinned backend, if specified. This is useful
            for explicitly specifying the devices other than relying on
            jax_platform_name.
          ici_mesh_shape: Shape of the logical mesh used for SPMD parallelism in
            each slice. The meaning of each mesh axis is defined by mesh_axis_names,
            so these two params must be the same length. If dcn_mesh_shape is
            present, the overall mesh is the product of ici_mesh_shape and
            dcn_mesh_shape. For example, an ici_mesh_shape of [2, 3, 4] with
            mesh_axis_names [&#39;replica&#39;, &#39;data&#39;, &#39;model&#39;] indicates 2-way replica
            parallelism, 3-way data parallelism, and 4-way model parallelism over 24
            devices. None, the default, is equivalent to a sequence of ones and
            means that the model is placed on a single device.
          dcn_mesh_shape: Shape of the logical mesh used for SPMD parallelism over
            multiple slices. The overall mesh is the product of ici_mesh_shape and
            dcn_mesh_shape, and the meaning of each mesh axis is defined by
            mesh_axis_names, so these three params must be the same length.
          logical_axis_rules: a priority-ordered sequence of KV tuples that maps
            logical axis names to either `None` (not sharded), &#39;model&#39; (to shard
            across the model-parallel submesh), or &#39;data&#39; (to shard across the
            data-parallel submesh).
        &#34;&#34;&#34;
        super().__init__(
            num_partitions=num_partitions,
            model_parallel_submesh=model_parallel_submesh,
            params_on_devices=params_on_devices,
            backend=backend,
            ici_mesh_shape=ici_mesh_shape,
            dcn_mesh_shape=dcn_mesh_shape,
        )
        if logical_axis_rules is None:
            logical_axis_rules = standard_logical_axis_rules()
        if ici_mesh_shape is not None and dcn_mesh_shape is not None:
            # Split batch over new replica axis.
            logical_axis_rules = (
                (k, (&#39;replica&#39;, &#39;data&#39;) if k == &#39;batch&#39; else v)
                for k, v in logical_axis_rules
            )
        self._logical_axis_rules = tuple(logical_axis_rules)
        (self._data_axis,) = flax_partitioning.logical_to_mesh_axes(
            [&#39;batch&#39;], self._logical_axis_rules
        )

    def partition(
            self,
            fn: Callable,  # pylint: disable=g-bare-generic
            in_axis_resources,
            out_axis_resources,
            static_argnums: Union[int, Sequence[int]] = (),
            donate_argnums: Union[int, Sequence[int]] = ()
    ) -&gt; PjittedFnWithContext:
        &#34;&#34;&#34;Partitions the function using jax.pjit.&#34;&#34;&#34;
        pjitted = pjit(
            fn,
            in_shardings=in_axis_resources,
            out_shardings=out_axis_resources,
            static_argnums=static_argnums,
            donate_argnums=donate_argnums,
        )

        return PjittedFnWithContext(pjitted, self.mesh, self._logical_axis_rules)

    @property
    def logical_axis_rules(self):
        &#34;&#34;&#34;Returns the logical axis rules.&#34;&#34;&#34;
        return self._logical_axis_rules

    def get_logical_axes(self, train_state):
        &#34;&#34;&#34;Returns a copy of TrainState with Optional[AxisNames] as leaves.&#34;&#34;&#34;
        return train_state.as_logical_axes()

    def get_mesh_axes(self, train_state):
        &#34;&#34;&#34;Returns a copy of TrainState with Optional[PartitionSpecs] as leaves.&#34;&#34;&#34;
        logical_axes = self.get_logical_axes(train_state)

        def _logical_to_mesh_axes(param_name, logical_axes):
            if logical_axes is None:
                return None
            elif logical_axes is traverse_util.empty_node:
                return traverse_util.empty_node
            try:
                return flax_partitioning.logical_to_mesh_axes(logical_axes,
                                                              self._logical_axis_rules)
            except ValueError as e:
                raise ValueError(f&#39;Failed to map logical axes for {param_name}&#39;) from e

        flat_logical_axes = traverse_util.flatten_dict(
            logical_axes.state_dict(), keep_empty_nodes=True, sep=&#39;/&#39;)
        flat_mesh_axes = {
            k: _logical_to_mesh_axes(k, v) for k, v in flat_logical_axes.items()
        }

        return logical_axes.restore_state(
            traverse_util.unflatten_dict(flat_mesh_axes, sep=&#39;/&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner" href="#fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner">BasePjitPartitioner</a></li>
<li><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner">BasePartitioner</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.PjitPartitioner.logical_axis_rules"><code class="name">var <span class="ident">logical_axis_rules</span></code></dt>
<dd>
<div class="desc"><p>Returns the logical axis rules.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def logical_axis_rules(self):
    &#34;&#34;&#34;Returns the logical axis rules.&#34;&#34;&#34;
    return self._logical_axis_rules</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.PjitPartitioner.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>self, fn:Callable, in_axis_resources, out_axis_resources, static_argnums:Union[int,Sequence[int]]=(), donate_argnums:Union[int,Sequence[int]]=()) ><a title="fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext" href="#fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext">PjittedFnWithContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Partitions the function using jax.pjit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(
        self,
        fn: Callable,  # pylint: disable=g-bare-generic
        in_axis_resources,
        out_axis_resources,
        static_argnums: Union[int, Sequence[int]] = (),
        donate_argnums: Union[int, Sequence[int]] = ()
) -&gt; PjittedFnWithContext:
    &#34;&#34;&#34;Partitions the function using jax.pjit.&#34;&#34;&#34;
    pjitted = pjit(
        fn,
        in_shardings=in_axis_resources,
        out_shardings=out_axis_resources,
        static_argnums=static_argnums,
        donate_argnums=donate_argnums,
    )

    return PjittedFnWithContext(pjitted, self.mesh, self._logical_axis_rules)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner" href="#fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner">BasePjitPartitioner</a></b></code>:
<ul class="hlist">
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.data_mesh_size" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_mesh_size">data_mesh_size</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.data_shard_id" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shard_id">data_shard_id</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.data_shards" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shards">data_shards</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.get_data_layout" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_data_layout">get_data_layout</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.get_local_chunk_info" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_local_chunk_info">get_local_chunk_info</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.get_logical_axes" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_logical_axes">get_logical_axes</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.get_mesh_axes" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_mesh_axes">get_mesh_axes</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.move_params_to_devices" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.move_params_to_devices">move_params_to_devices</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext"><code class="flex name class">
<span>class <span class="ident">PjittedFnWithContext</span></span>
<span>(</span><span>pjitted_fn, partition_mesh:jax._src.mesh.Mesh, logical_axis_rules:Sequence[Tuple[str,Union[str,Tuple[str],ForwardRef(None)]]]=())</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps pjitted function to apply the appropriate contexts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PjittedFnWithContext(PartitionedCallable):
    &#34;&#34;&#34;Wraps pjitted function to apply the appropriate contexts.&#34;&#34;&#34;

    def __init__(self,
                 pjitted_fn,
                 partition_mesh: Mesh,
                 logical_axis_rules: flax_partitioning.LogicalRules = ()):
        self._pjitted_fn = pjitted_fn
        self._mesh = partition_mesh
        self._logical_axis_rules = logical_axis_rules

    def __call__(self, *args, **kwargs):
        with Mesh(self._mesh.devices,
                  self._mesh.axis_names), flax_partitioning.axis_rules(self._logical_axis_rules):
            return self._pjitted_fn(*args, **kwargs)

    def lower(self, *args, **kwargs):
        with Mesh(self._mesh.devices,
                  self._mesh.axis_names), flax_partitioning.axis_rules(self._logical_axis_rules):
            return self._pjitted_fn.lower(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Callable</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext.lower"><code class="name flex">
<span>def <span class="ident">lower</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lower(self, *args, **kwargs):
    with Mesh(self._mesh.devices,
              self._mesh.axis_names), flax_partitioning.axis_rules(self._logical_axis_rules):
        return self._pjitted_fn.lower(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fjformer.partition_utils" href="index.html">fjformer.partition_utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fjformer.partition_utils.t5x_partitioning.bounds_from_last_device" href="#fjformer.partition_utils.t5x_partitioning.bounds_from_last_device">bounds_from_last_device</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.default_mesh" href="#fjformer.partition_utils.t5x_partitioning.default_mesh">default_mesh</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.get_coords" href="#fjformer.partition_utils.t5x_partitioning.get_coords">get_coords</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.get_cpu_mesh" href="#fjformer.partition_utils.t5x_partitioning.get_cpu_mesh">get_cpu_mesh</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.get_gpu_mesh" href="#fjformer.partition_utils.t5x_partitioning.get_gpu_mesh">get_gpu_mesh</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.get_mesh" href="#fjformer.partition_utils.t5x_partitioning.get_mesh">get_mesh</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.global_mesh_defined" href="#fjformer.partition_utils.t5x_partitioning.global_mesh_defined">global_mesh_defined</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.host_local_array_to_global_array" href="#fjformer.partition_utils.t5x_partitioning.host_local_array_to_global_array">host_local_array_to_global_array</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.standard_logical_axis_rules" href="#fjformer.partition_utils.t5x_partitioning.standard_logical_axis_rules">standard_logical_axis_rules</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.with_sharding_constraint" href="#fjformer.partition_utils.t5x_partitioning.with_sharding_constraint">with_sharding_constraint</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fjformer.partition_utils.t5x_partitioning.AxisNames" href="#fjformer.partition_utils.t5x_partitioning.AxisNames">AxisNames</a></code></h4>
</li>
<li>
<h4><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner">BasePartitioner</a></code></h4>
<ul class="">
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.compile" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.compile">compile</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_mesh_size" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_mesh_size">data_mesh_size</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_partition_spec" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_partition_spec">data_partition_spec</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shard_id" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shard_id">data_shard_id</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shards" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.data_shards">data_shards</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_data_layout" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_data_layout">get_data_layout</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_local_chunk_info" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_local_chunk_info">get_local_chunk_info</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_logical_axes" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_logical_axes">get_logical_axes</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_mesh_axes" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.get_mesh_axes">get_mesh_axes</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.mesh" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.mesh">mesh</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.move_params_to_devices" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.move_params_to_devices">move_params_to_devices</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.params_on_devices" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.params_on_devices">params_on_devices</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePartitioner.partition" href="#fjformer.partition_utils.t5x_partitioning.BasePartitioner.partition">partition</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner" href="#fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner">BasePjitPartitioner</a></code></h4>
<ul class="">
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.compile" href="#fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.compile">compile</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.mesh" href="#fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.mesh">mesh</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.partition" href="#fjformer.partition_utils.t5x_partitioning.BasePjitPartitioner.partition">partition</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fjformer.partition_utils.t5x_partitioning.DataLayout" href="#fjformer.partition_utils.t5x_partitioning.DataLayout">DataLayout</a></code></h4>
<ul class="">
<li><code><a title="fjformer.partition_utils.t5x_partitioning.DataLayout.batch_size" href="#fjformer.partition_utils.t5x_partitioning.DataLayout.batch_size">batch_size</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.DataLayout.is_first_host_in_replica_set" href="#fjformer.partition_utils.t5x_partitioning.DataLayout.is_first_host_in_replica_set">is_first_host_in_replica_set</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.DataLayout.num_shards" href="#fjformer.partition_utils.t5x_partitioning.DataLayout.num_shards">num_shards</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.DataLayout.shard_id" href="#fjformer.partition_utils.t5x_partitioning.DataLayout.shard_id">shard_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fjformer.partition_utils.t5x_partitioning.LocalChunkInfo" href="#fjformer.partition_utils.t5x_partitioning.LocalChunkInfo">LocalChunkInfo</a></code></h4>
<ul class="">
<li><code><a title="fjformer.partition_utils.t5x_partitioning.LocalChunkInfo.replica_id" href="#fjformer.partition_utils.t5x_partitioning.LocalChunkInfo.replica_id">replica_id</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.LocalChunkInfo.slice" href="#fjformer.partition_utils.t5x_partitioning.LocalChunkInfo.slice">slice</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fjformer.partition_utils.t5x_partitioning.LocalChunker" href="#fjformer.partition_utils.t5x_partitioning.LocalChunker">LocalChunker</a></code></h4>
<ul class="">
<li><code><a title="fjformer.partition_utils.t5x_partitioning.LocalChunker.get_local_chunk_info" href="#fjformer.partition_utils.t5x_partitioning.LocalChunker.get_local_chunk_info">get_local_chunk_info</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.LocalChunker.get_replica_id" href="#fjformer.partition_utils.t5x_partitioning.LocalChunker.get_replica_id">get_replica_id</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.LocalChunker.get_shard_id" href="#fjformer.partition_utils.t5x_partitioning.LocalChunker.get_shard_id">get_shard_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fjformer.partition_utils.t5x_partitioning.PjitPartitioner" href="#fjformer.partition_utils.t5x_partitioning.PjitPartitioner">PjitPartitioner</a></code></h4>
<ul class="">
<li><code><a title="fjformer.partition_utils.t5x_partitioning.PjitPartitioner.logical_axis_rules" href="#fjformer.partition_utils.t5x_partitioning.PjitPartitioner.logical_axis_rules">logical_axis_rules</a></code></li>
<li><code><a title="fjformer.partition_utils.t5x_partitioning.PjitPartitioner.partition" href="#fjformer.partition_utils.t5x_partitioning.PjitPartitioner.partition">partition</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext" href="#fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext">PjittedFnWithContext</a></code></h4>
<ul class="">
<li><code><a title="fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext.lower" href="#fjformer.partition_utils.t5x_partitioning.PjittedFnWithContext.lower">lower</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>